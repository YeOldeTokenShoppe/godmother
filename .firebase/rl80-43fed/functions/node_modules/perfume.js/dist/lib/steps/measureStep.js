"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.measureStep = void 0;
var constants_1 = require("../constants");
var reportPerf_1 = require("../reportPerf");
var config_1 = require("../config");
var vitalsScore_1 = require("../vitalsScore");
var measureStep = function (step, startMark, endMark) {
    var stepMetricName = constants_1.S + step;
    var startMarkExists = constants_1.WP.getEntriesByName(constants_1.M + startMark).length > 0;
    var endMarkExists = constants_1.WP.getEntriesByName(constants_1.M + endMark).length > 0;
    if (!endMarkExists ||
        !startMarkExists ||
        !config_1.config.steps ||
        !config_1.config.steps[step]) {
        return;
    }
    var _a = vitalsScore_1.STEP_THRESHOLDS[config_1.config.steps[step].threshold], maxOutlierThreshold = _a.maxOutlierThreshold, vitalsThresholds = _a.vitalsThresholds;
    var stepMeasure = constants_1.WP.measure(stepMetricName, constants_1.M + startMark, constants_1.M + endMark);
    // checking to ensure stepMeasure is defined - it can be undefined
    // if measure is called on a mark that has already been measured and cleared
    if (!stepMeasure) {
        return;
    }
    var duration = stepMeasure.duration;
    if (duration <= maxOutlierThreshold) {
        var score = (0, vitalsScore_1.getRating)(duration, vitalsThresholds);
        // Do not want to measure or log negative metrics
        if (duration >= 0) {
            (0, reportPerf_1.reportPerf)('userJourneyStep', duration, score, { stepName: step }, undefined);
            constants_1.WP.measure("step.".concat(step, "_vitals_").concat(score), {
                start: stepMeasure.startTime + stepMeasure.duration,
                end: stepMeasure.startTime + stepMeasure.duration,
                detail: {
                    type: 'stepVital',
                    duration: duration,
                },
            });
        }
    }
};
exports.measureStep = measureStep;
//# sourceMappingURL=measureStep.js.map