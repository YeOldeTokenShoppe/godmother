"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackUJNavigation = exports.recordEndMark = exports.recordStartMark = exports.getActiveStepsFromNavigationSteps = void 0;
var config_1 = require("./../config");
var steps_1 = require("./steps");
/**
 * We only report the active steps in the last 2 navigation step to prevent
 * Convert the steps.navigationSteps to an array of active steps.
 * "stale steps" from being reported.
 *
 * "stale steps" are defined as steps where the start mark was executed but the
 * corresponding end mark was never executed - thus leaving it as a "stale step"
 */
var getActiveStepsFromNavigationSteps = function () {
    var navigationSteps = (0, steps_1.getNavigationState)();
    var startMarkToStepsMap = steps_1.steps.startMarkToStepsMap;
    var numberOfSteps = Object.keys(navigationSteps).length;
    if (numberOfSteps === 0) {
        return {};
    }
    var activeSteps = {};
    var currentNavIndex = numberOfSteps - 1;
    var currentNavStep = (0, steps_1.getStepsFromNavigation)(currentNavIndex);
    Object.keys(currentNavStep).forEach(function (startMark) {
        var _a;
        var ongoingSteps = (_a = startMarkToStepsMap[startMark]) !== null && _a !== void 0 ? _a : [];
        Object.keys(ongoingSteps).forEach(function (step) {
            activeSteps[step] = true;
        });
    });
    // if nav length is >1, then check the nav step prior as well
    if (numberOfSteps > 1) {
        var prevNavStep = (0, steps_1.getStepsFromNavigation)(currentNavIndex - 1);
        Object.keys(prevNavStep).forEach(function (startMark) {
            var _a;
            var prevNavSteps = (_a = startMarkToStepsMap[startMark]) !== null && _a !== void 0 ? _a : [];
            Object.keys(prevNavSteps).forEach(function (step) {
                activeSteps[step] = true;
            });
        });
    }
    return activeSteps;
};
exports.getActiveStepsFromNavigationSteps = getActiveStepsFromNavigationSteps;
// start mark for navigationSteps data structure
var recordStartMark = function (startMark) {
    var navigationSteps = steps_1.steps.navigationSteps;
    var numberOfSteps = Object.keys(navigationSteps).length;
    // if we don't have any initial states recorded, initialize one
    var navigationLength = numberOfSteps > 0 ? numberOfSteps : 1;
    var lastNavIndex = navigationLength - 1;
    var currentMarks = (0, steps_1.getStepsFromNavigation)(lastNavIndex) || [];
    var newCurrentMark = currentMarks;
    newCurrentMark[startMark] = true;
    navigationSteps[lastNavIndex] = newCurrentMark;
};
exports.recordStartMark = recordStartMark;
var recordEndMark = function (endMark) {
    var navigationSteps = steps_1.steps.navigationSteps, finalMarkToStepsMap = steps_1.steps.finalMarkToStepsMap;
    var navigationLength = Object.keys(navigationSteps).length;
    if (navigationLength === 0) {
        return;
    }
    var currentNavIndex = navigationLength - 1;
    var ongoingNavStep = (0, steps_1.getStepsFromNavigation)(currentNavIndex);
    if (!ongoingNavStep || !finalMarkToStepsMap[endMark]) {
        return;
    }
    var endMarkMap = finalMarkToStepsMap[endMark];
    if (!endMarkMap) {
        return;
    }
    /**
     * loop through all steps where end mark is present and check if their start mark is present
     * in the navigation state. If so, remove it to signal that the step has been completed
     */
    Object.keys(endMarkMap).forEach(function (startMark) {
        if (ongoingNavStep[startMark]) {
            var currentNavStep = (0, steps_1.getStepsFromNavigation)(currentNavIndex) || {};
            // Only remove the startMark, not other ongoing steps
            currentNavStep[startMark] = false;
            // if start mark is in navigation state, remove it to signal that the step has completed
            navigationSteps[currentNavIndex] = currentNavStep;
        }
        // if nav length is >1, then check the nav step prior as well
        if (navigationLength > 1) {
            var lastNavIndex = currentNavIndex - 1;
            var lastNavStep = (0, steps_1.getStepsFromNavigation)(lastNavIndex);
            if (lastNavStep[startMark]) {
                lastNavStep[startMark] = false;
                navigationSteps[lastNavIndex] = lastNavStep;
            }
        }
    });
};
exports.recordEndMark = recordEndMark;
/**
 * An API consumers must use to update internal state based on page/screen navigations.
 * Internal state must be updated when the following are true
 * 1. Journey marks are hit
 * 2. Page navigations occur
 * This function ensures the 2nd case is covered to help prevent "stale"
 * steps that don't hit their final mark because the users navigates
 * backwards in journey.
 */
var trackUJNavigation = function () {
    var _a;
    // navigationSteps are 0-index based, so size will give us the next key value
    var navigationLength = Object.keys(steps_1.steps.navigationSteps).length;
    steps_1.steps.navigationSteps[navigationLength] = {};
    // when navigating, we should notify the user in case stale steps are
    // removed from the state during navigations
    var activeSteps = (0, exports.getActiveStepsFromNavigationSteps)();
    (_a = config_1.config.onMarkStep) === null || _a === void 0 ? void 0 : _a.call(config_1.config, '', Object.keys(activeSteps));
};
exports.trackUJNavigation = trackUJNavigation;
//# sourceMappingURL=navigationSteps.js.map