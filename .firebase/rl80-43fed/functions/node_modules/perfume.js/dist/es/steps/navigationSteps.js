import { config } from './../config';
import { getNavigationState, getStepsFromNavigation, steps } from './steps';
/**
 * We only report the active steps in the last 2 navigation step to prevent
 * Convert the steps.navigationSteps to an array of active steps.
 * "stale steps" from being reported.
 *
 * "stale steps" are defined as steps where the start mark was executed but the
 * corresponding end mark was never executed - thus leaving it as a "stale step"
 */
export var getActiveStepsFromNavigationSteps = function () {
    var navigationSteps = getNavigationState();
    var startMarkToStepsMap = steps.startMarkToStepsMap;
    var numberOfSteps = Object.keys(navigationSteps).length;
    if (numberOfSteps === 0) {
        return {};
    }
    var activeSteps = {};
    var currentNavIndex = numberOfSteps - 1;
    var currentNavStep = getStepsFromNavigation(currentNavIndex);
    Object.keys(currentNavStep).forEach(function (startMark) {
        var _a;
        var ongoingSteps = (_a = startMarkToStepsMap[startMark]) !== null && _a !== void 0 ? _a : [];
        Object.keys(ongoingSteps).forEach(function (step) {
            activeSteps[step] = true;
        });
    });
    // if nav length is >1, then check the nav step prior as well
    if (numberOfSteps > 1) {
        var prevNavStep = getStepsFromNavigation(currentNavIndex - 1);
        Object.keys(prevNavStep).forEach(function (startMark) {
            var _a;
            var prevNavSteps = (_a = startMarkToStepsMap[startMark]) !== null && _a !== void 0 ? _a : [];
            Object.keys(prevNavSteps).forEach(function (step) {
                activeSteps[step] = true;
            });
        });
    }
    return activeSteps;
};
// start mark for navigationSteps data structure
export var recordStartMark = function (startMark) {
    var navigationSteps = steps.navigationSteps;
    var numberOfSteps = Object.keys(navigationSteps).length;
    // if we don't have any initial states recorded, initialize one
    var navigationLength = numberOfSteps > 0 ? numberOfSteps : 1;
    var lastNavIndex = navigationLength - 1;
    var currentMarks = getStepsFromNavigation(lastNavIndex) || [];
    var newCurrentMark = currentMarks;
    newCurrentMark[startMark] = true;
    navigationSteps[lastNavIndex] = newCurrentMark;
};
export var recordEndMark = function (endMark) {
    var navigationSteps = steps.navigationSteps, finalMarkToStepsMap = steps.finalMarkToStepsMap;
    var navigationLength = Object.keys(navigationSteps).length;
    if (navigationLength === 0) {
        return;
    }
    var currentNavIndex = navigationLength - 1;
    var ongoingNavStep = getStepsFromNavigation(currentNavIndex);
    if (!ongoingNavStep || !finalMarkToStepsMap[endMark]) {
        return;
    }
    var endMarkMap = finalMarkToStepsMap[endMark];
    if (!endMarkMap) {
        return;
    }
    /**
     * loop through all steps where end mark is present and check if their start mark is present
     * in the navigation state. If so, remove it to signal that the step has been completed
     */
    Object.keys(endMarkMap).forEach(function (startMark) {
        if (ongoingNavStep[startMark]) {
            var currentNavStep = getStepsFromNavigation(currentNavIndex) || {};
            // Only remove the startMark, not other ongoing steps
            currentNavStep[startMark] = false;
            // if start mark is in navigation state, remove it to signal that the step has completed
            navigationSteps[currentNavIndex] = currentNavStep;
        }
        // if nav length is >1, then check the nav step prior as well
        if (navigationLength > 1) {
            var lastNavIndex = currentNavIndex - 1;
            var lastNavStep = getStepsFromNavigation(lastNavIndex);
            if (lastNavStep[startMark]) {
                lastNavStep[startMark] = false;
                navigationSteps[lastNavIndex] = lastNavStep;
            }
        }
    });
};
/**
 * An API consumers must use to update internal state based on page/screen navigations.
 * Internal state must be updated when the following are true
 * 1. Journey marks are hit
 * 2. Page navigations occur
 * This function ensures the 2nd case is covered to help prevent "stale"
 * steps that don't hit their final mark because the users navigates
 * backwards in journey.
 */
export var trackUJNavigation = function () {
    var _a;
    // navigationSteps are 0-index based, so size will give us the next key value
    var navigationLength = Object.keys(steps.navigationSteps).length;
    steps.navigationSteps[navigationLength] = {};
    // when navigating, we should notify the user in case stale steps are
    // removed from the state during navigations
    var activeSteps = getActiveStepsFromNavigationSteps();
    (_a = config.onMarkStep) === null || _a === void 0 ? void 0 : _a.call(config, '', Object.keys(activeSteps));
};
//# sourceMappingURL=navigationSteps.js.map