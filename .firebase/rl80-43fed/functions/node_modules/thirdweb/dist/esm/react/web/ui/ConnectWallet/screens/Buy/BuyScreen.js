import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { IdCardIcon } from "@radix-ui/react-icons";
import { useMemo, useState } from "react";
import { NATIVE_TOKEN_ADDRESS } from "../../../../../../constants/addresses.js";
import { isSwapRequiredPostOnramp } from "../../../../../../pay/buyWithFiat/isSwapRequiredPostOnramp.js";
import { formatNumber } from "../../../../../../utils/formatNumber.js";
import { toEther } from "../../../../../../utils/units.js";
import { fontSize, iconSize, spacing, } from "../../../../../core/design-system/index.js";
import { useChainName } from "../../../../../core/hooks/others/useChainQuery.js";
import { useWalletBalance } from "../../../../../core/hooks/others/useWalletBalance.js";
import { useBuyWithCryptoQuote } from "../../../../../core/hooks/pay/useBuyWithCryptoQuote.js";
import { useBuyWithFiatQuote } from "../../../../../core/hooks/pay/useBuyWithFiatQuote.js";
import { useActiveAccount } from "../../../../hooks/wallets/useActiveAccount.js";
import { LoadingScreen } from "../../../../wallets/shared/LoadingScreen.js";
import { ChainName } from "../../../components/ChainName.js";
import { Drawer, DrawerOverlay, useDrawer, } from "../../../components/Drawer.js";
import { Skeleton } from "../../../components/Skeleton.js";
import { Spacer } from "../../../components/Spacer.js";
import { Spinner } from "../../../components/Spinner.js";
import { SwitchNetworkButton } from "../../../components/SwitchNetwork.js";
import { TokenIcon } from "../../../components/TokenIcon.js";
import { Container, Line, ModalHeader } from "../../../components/basic.js";
import { Button } from "../../../components/buttons.js";
import { Text } from "../../../components/text.js";
import { TokenSymbol } from "../../../components/token/TokenSymbol.js";
import { ConnectButton } from "../../ConnectButton.js";
import { ChainButton, NetworkSelectorContent } from "../../NetworkSelector.js";
import { CoinsIcon } from "../../icons/CoinsIcon.js";
import { TokenSelector } from "../TokenSelector.js";
import { WalletSwitcherConnectionScreen } from "../WalletSwitcherConnectionScreen.js";
import { NATIVE_TOKEN, isNativeToken, } from "../nativeToken.js";
import { EstimatedTimeAndFees } from "./EstimatedTimeAndFees.js";
import { PayTokenIcon } from "./PayTokenIcon.js";
import { PayWithCreditCard } from "./PayWIthCreditCard.js";
import { ReceiverWalletDrawerScreen } from "./ReceiverWalletSelectionScreen.js";
import { WalletSelectorButton } from "./WalletSelectorButton.js";
import { CurrencySelection } from "./fiat/CurrencySelection.js";
import { FiatFlow } from "./fiat/FiatFlow.js";
import { useBuyTxStates } from "./main/useBuyTxStates.js";
import { useEnabledPaymentMethods } from "./main/useEnabledPaymentMethods.js";
import { useUISelectionStates } from "./main/useUISelectionStates.js";
import { openOnrampPopup } from "./openOnRamppopup.js";
import { BuyTokenInput } from "./swap/BuyTokenInput.js";
import { FiatFees, SwapFees } from "./swap/Fees.js";
import { PayWithCrypto } from "./swap/PayWithCrypto.js";
import { SwapFlow } from "./swap/SwapFlow.js";
import { WalletSwitcherDrawerContent } from "./swap/WalletSwitcherDrawerContent.js";
import { addPendingTx } from "./swap/pendingSwapTx.js";
import { useBuySupportedDestinations, useBuySupportedSources, } from "./swap/useSwapSupportedChains.js";
import { usePayerSetup } from "./usePayerSetup.js";
/**
 * @internal
 */
export default function BuyScreen(props) {
    const supportedDestinationsQuery = useBuySupportedDestinations(props.client);
    if (!supportedDestinationsQuery.data) {
        return _jsx(LoadingScreen, {});
    }
    return (_jsx(BuyScreenContent, { ...props, onViewPendingTx: props.onViewPendingTx, supportedDestinations: supportedDestinationsQuery.data, buyForTx: props.buyForTx }));
}
/**
 * @internal
 */
function BuyScreenContent(props) {
    const { client, supportedDestinations, connectLocale, payOptions, buyForTx } = props;
    const activeAccount = useActiveAccount();
    const { payer, setPayer } = usePayerSetup();
    const [screen, setScreen] = useState({
        id: "main",
    });
    // UI selection
    const { tokenAmount, setTokenAmount, toChain, setToChain, deferredTokenAmount, fromChain, setFromChain, toToken, setToToken, fromToken, setFromToken, selectedCurrency, setSelectedCurrency, } = useUISelectionStates({
        payOptions,
        buyForTx,
        supportedDestinations,
    });
    // check if the screen is expanded or not
    // update supportedSources whenever toToken or toChain is updated
    const supportedSourcesQuery = useBuySupportedSources({
        client: props.client,
        destinationChainId: toChain.id,
        destinationTokenAddress: isNativeToken(toToken)
            ? NATIVE_TOKEN_ADDRESS
            : toToken.address,
    });
    const destinationSupportedTokens = useMemo(() => {
        return createSupportedTokens(supportedDestinations, payOptions, props.supportedTokens);
    }, [props.supportedTokens, supportedDestinations, payOptions]);
    const sourceSupportedTokens = useMemo(() => {
        if (!supportedSourcesQuery.data) {
            return undefined;
        }
        return createSupportedTokens(supportedSourcesQuery.data, payOptions, props.supportedTokens);
    }, [props.supportedTokens, supportedSourcesQuery.data, payOptions]);
    // screens ----------------------------
    if (screen.id === "connect-payer-wallet") {
        return (_jsx(WalletSwitcherConnectionScreen, { accountAbstraction: props.connectOptions?.accountAbstraction, appMetadata: props.connectOptions?.appMetadata, chain: props.connectOptions?.chain, chains: props.connectOptions?.chains, client: props.client, connectLocale: props.connectLocale, isEmbed: props.isEmbed, onBack: () => setScreen(screen.backScreen), onSelect: (w) => {
                const account = w.getAccount();
                const chain = w.getChain();
                if (w && account && chain) {
                    setPayer({
                        account,
                        chain,
                        wallet: w,
                    });
                }
            }, recommendedWallets: props.connectOptions?.recommendedWallets, showAllWallets: !!props.connectOptions?.showAllWallets, walletConnect: props.connectOptions?.walletConnect, wallets: props.connectOptions?.wallets }));
    }
    if (screen.id === "swap-flow" && payer) {
        return (_jsx(SwapFlow, { isBuyForTx: !!props.buyForTx, isEmbed: props.isEmbed, client: client, onBack: () => {
                setScreen({
                    id: "buy-with-crypto",
                });
            }, buyWithCryptoQuote: screen.quote, payer: payer, onViewPendingTx: props.onViewPendingTx, isFiatFlow: false, onDone: props.onDone, onTryAgain: () => {
                setScreen({
                    id: "buy-with-crypto",
                });
            } }));
    }
    if (screen.id === "fiat-flow" && payer) {
        return (_jsx(FiatFlow, { isBuyForTx: !!props.buyForTx, quote: screen.quote, onBack: () => {
                setScreen({
                    id: "buy-with-fiat",
                });
            }, client: client, testMode: props.payOptions.buyWithFiat !== false &&
                props.payOptions.buyWithFiat?.testMode === true, theme: typeof props.theme === "string" ? props.theme : props.theme.type, onViewPendingTx: props.onViewPendingTx, openedWindow: screen.openedWindow, onDone: props.onDone, isEmbed: props.isEmbed, payer: payer }));
    }
    if (screen.id === "select-currency") {
        const goBack = () => setScreen(screen.backScreen);
        return (_jsx(CurrencySelection, { onSelect: (currency) => {
                goBack();
                setSelectedCurrency(currency);
            }, onBack: goBack }));
    }
    if (screen.id === "select-to-token") {
        const chains = supportedDestinations.map((x) => x.chain);
        const goBack = () => setScreen(screen.backScreen);
        // if token selection is disabled - only show network selector screen
        if (payOptions.prefillBuy?.allowEdits?.token === false) {
            return (_jsx(ChainSelectionScreen, { chains: chains, client: props.client, connectLocale: props.connectLocale, setChain: setToChain, goBack: goBack }));
        }
        return (_jsx(TokenSelector, { onBack: goBack, tokenList: ((toChain?.id ? destinationSupportedTokens[toChain.id] : undefined) ||
                []).filter((x) => x.address !== NATIVE_TOKEN_ADDRESS), onTokenSelect: (tokenInfo) => {
                setToToken(tokenInfo);
                goBack();
            }, chain: toChain, chainSelection: 
            // hide chain selection if it's disabled
            payOptions.prefillBuy?.allowEdits?.chain !== false
                ? {
                    chains: chains,
                    select: (c) => {
                        setToChain(c);
                    },
                }
                : undefined, connectLocale: connectLocale, client: client, modalTitle: "Buy" }));
    }
    if (screen.id === "select-from-token" &&
        supportedSourcesQuery.data &&
        sourceSupportedTokens) {
        const chains = supportedSourcesQuery.data.map((x) => x.chain);
        const goBack = () => setScreen(screen.backScreen);
        // if token selection is disabled - only show network selector screen
        if (payOptions.buyWithCrypto !== false &&
            payOptions.buyWithCrypto?.prefillSource?.allowEdits?.token === false) {
            return (_jsx(ChainSelectionScreen, { chains: chains, client: props.client, connectLocale: props.connectLocale, setChain: setFromChain, goBack: goBack }));
        }
        return (_jsx(TokenSelector, { onBack: goBack, tokenList: ((fromChain?.id ? sourceSupportedTokens[fromChain.id] : undefined) ||
                []).filter((x) => x.address !== NATIVE_TOKEN_ADDRESS), onTokenSelect: (tokenInfo) => {
                setFromToken(tokenInfo);
                goBack();
            }, chain: fromChain, chainSelection: 
            // hide chain selection if it's disabled
            payOptions.buyWithCrypto !== false &&
                payOptions.buyWithCrypto?.prefillSource?.allowEdits?.chain !== false
                ? {
                    chains: supportedSourcesQuery.data.map((x) => x.chain),
                    select: (c) => setFromChain(c),
                }
                : undefined, connectLocale: connectLocale, client: client, modalTitle: "Pay with" }));
    }
    return (_jsx(Container, { animate: "fadein", children: _jsxs("div", { children: [screen.id === "main" && (_jsx(MainScreen, { payerAccount: payer?.account, buyForTx: buyForTx, client: client, onSelectBuyToken: () => setScreen({ id: "select-to-token", backScreen: screen }), payOptions: payOptions, setTokenAmount: setTokenAmount, toChain: toChain, toToken: toToken, tokenAmount: tokenAmount, connectOptions: props.connectOptions, onViewPendingTx: props.onViewPendingTx, setScreen: setScreen, supportedDestinations: supportedDestinations, onBack: props.onBack, theme: props.theme })), (screen.id === "select-payment-method" ||
                    screen.id === "buy-with-crypto" ||
                    screen.id === "buy-with-fiat") &&
                    payer && (_jsxs(TokenSelectedLayout, { selectedChain: toChain, selectedToken: toToken, tokenAmount: tokenAmount, client: client, onBack: () => {
                        if (screen.id === "buy-with-crypto" ||
                            screen.id === "buy-with-fiat") {
                            setScreen({ id: "select-payment-method" });
                        }
                        else if (screen.id === "select-payment-method") {
                            setScreen({ id: "main" });
                        }
                    }, children: [screen.id === "select-payment-method" && (_jsx(PaymentMethodSelection, { setScreen: (id) => setScreen({ id }) })), screen.id === "buy-with-crypto" && activeAccount && (_jsx(SwapScreenContent, { setScreen: setScreen, tokenAmount: deferredTokenAmount, toChain: toChain, toToken: toToken, fromChain: fromChain, fromToken: fromToken, showFromTokenSelector: () => {
                                setScreen({
                                    id: "select-from-token",
                                    backScreen: screen,
                                });
                            }, payer: payer, buyForTx: buyForTx || null, client: client, isEmbed: props.isEmbed, onDone: props.onDone, onViewPendingTx: props.onViewPendingTx, payOptions: payOptions, connectLocale: connectLocale, connectOptions: props.connectOptions, setPayer: setPayer, 
                            // pass it even though we are passing payer, because payer might be different
                            activeAccount: activeAccount })), screen.id === "buy-with-fiat" && (_jsx(FiatScreenContent, { setScreen: setScreen, tokenAmount: deferredTokenAmount, toChain: toChain, toToken: toToken, selectedCurrency: selectedCurrency, buyForTx: buyForTx || null, client: client, isEmbed: props.isEmbed, onDone: props.onDone, onViewPendingTx: props.onViewPendingTx, payOptions: payOptions, theme: props.theme, showCurrencySelector: () => {
                                setScreen({
                                    id: "select-currency",
                                    backScreen: screen,
                                });
                            }, payer: payer, setTokenAmount: setTokenAmount }))] }))] }) }));
}
function SelectedTokenInfo(props) {
    return (_jsx("div", { children: _jsxs(Container, { flex: "row", gap: "sm", center: "y", style: {
                justifyContent: "space-between",
            }, children: [_jsxs(Container, { flex: "row", gap: "xs", center: "y", children: [_jsx(Text, { color: "primaryText", "data-testid": "tokenAmount", size: "xxl", children: formatNumber(Number(props.tokenAmount), 5) }), _jsxs(Container, { flex: "row", gap: "xxs", center: "y", children: [_jsx(TokenSymbol, { token: props.selectedToken, chain: props.selectedChain, size: "md", color: "secondaryText" }), _jsx(PayTokenIcon, { chain: props.selectedChain, client: props.client, size: "sm", token: props.selectedToken })] })] }), _jsx(ChainName, { chain: props.selectedChain, client: props.client, size: "sm", short: true })] }) }));
}
function MainScreen(props) {
    const { showPaymentSelection, buyWithCryptoEnabled, buyWithFiatEnabled } = useEnabledPaymentMethods({
        payOptions: props.payOptions,
        supportedDestinations: props.supportedDestinations,
        toChain: props.toChain,
        toToken: props.toToken,
    });
    const [hasEditedAmount, setHasEditedAmount] = useState(false);
    const { buyForTx, setTokenAmount, payerAccount, client, tokenAmount, payOptions, toToken, toChain, } = props;
    // Buy Transaction flow states
    const { amountNeeded } = useBuyTxStates({
        setTokenAmount,
        buyForTx: buyForTx || null,
        hasEditedAmount,
        account: payerAccount || null,
    });
    const disableContinue = !tokenAmount;
    return (_jsxs(Container, { p: "lg", children: [_jsx(ModalHeader, { title: props.buyForTx ? `Not enough ${props.buyForTx.tokenSymbol}` : "Buy", onBack: props.onBack }), amountNeeded && props.buyForTx ? (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "lg" }), _jsx(BuyForTxUI, { amountNeeded: String(formatNumber(Number(toEther(amountNeeded)), 4)), buyForTx: props.buyForTx, client: client })] })) : (_jsx(Spacer, { y: "xl" })), _jsx(BuyTokenInput, { value: tokenAmount, onChange: async (value) => {
                    setHasEditedAmount(true);
                    setTokenAmount(value);
                }, freezeAmount: payOptions.prefillBuy?.allowEdits?.amount === false, freezeChainAndToken: payOptions.prefillBuy?.allowEdits?.chain === false &&
                    payOptions.prefillBuy?.allowEdits?.token === false, token: toToken, chain: toChain, onSelectToken: props.onSelectBuyToken, client: props.client, hideTokenSelector: !!props.buyForTx }), _jsx(Spacer, { y: "xl" }), _jsxs(Container, { flex: "column", gap: "sm", children: [!payerAccount ? (_jsx("div", { children: _jsx(ConnectButton, { ...props.connectOptions, client: props.client, theme: props.theme, connectButton: {
                                style: {
                                    width: "100%",
                                },
                            } }) })) : (_jsx(Button, { variant: "accent", fullWidth: true, disabled: disableContinue, "data-disabled": disableContinue, onClick: () => {
                            if (showPaymentSelection) {
                                props.setScreen({ id: "select-payment-method" });
                            }
                            else if (buyWithCryptoEnabled) {
                                props.setScreen({ id: "buy-with-crypto" });
                            }
                            else if (buyWithFiatEnabled) {
                                props.setScreen({ id: "buy-with-fiat" });
                            }
                            else {
                                console.error("No payment method enabled");
                            }
                        }, children: "Continue" })), payerAccount && (_jsx(Button, { variant: "outline", fullWidth: true, style: {
                            padding: spacing.xs,
                            fontSize: fontSize.sm,
                        }, onClick: props.onViewPendingTx, children: "View all transactions" }))] })] }));
}
function TokenSelectedLayout(props) {
    return (_jsxs(Container, { children: [_jsx(Container, { p: "lg", children: _jsx(ModalHeader, { title: "Buy", onBack: props.onBack }) }), _jsxs(Container, { px: "lg", style: {
                    paddingBottom: spacing.lg,
                }, children: [_jsx(Spacer, { y: "xs" }), _jsx(SelectedTokenInfo, { selectedToken: props.selectedToken, selectedChain: props.selectedChain, tokenAmount: props.tokenAmount, client: props.client }), _jsx(Spacer, { y: "md" }), _jsx(Line, {}), _jsx(Spacer, { y: "lg" }), _jsx(Text, { size: "sm", children: " Pay with " }), _jsx(Spacer, { y: "sm" }), props.children] })] }));
}
function PaymentMethodSelection(props) {
    return (_jsx(Container, { animate: "fadein", children: _jsxs(Container, { flex: "column", gap: "sm", children: [_jsxs(Button, { variant: "outline", bg: "tertiaryBg", onClick: () => props.setScreen("buy-with-fiat"), gap: "sm", style: {
                        justifyContent: "flex-start",
                        textAlign: "left",
                    }, children: [_jsx(Container, { color: "secondaryText", flex: "row", center: "both", children: _jsx(IdCardIcon, { style: {
                                    width: iconSize.md,
                                    height: iconSize.md,
                                } }) }), _jsxs(Container, { flex: "column", gap: "xxs", children: [_jsx(Text, { size: "md", color: "primaryText", children: "Credit Card" }), _jsx(Text, { size: "xs", children: "Easily and securely make payments" })] })] }), _jsxs(Button, { variant: "outline", bg: "tertiaryBg", onClick: () => props.setScreen("buy-with-crypto"), style: {
                        justifyContent: "flex-start",
                    }, gap: "sm", children: [_jsx(Container, { color: "secondaryText", flex: "row", center: "both", children: _jsx(CoinsIcon, { size: iconSize.md }) }), _jsxs(Container, { flex: "column", gap: "xxs", children: [_jsx(Text, { size: "md", color: "primaryText", children: "Crypto" }), _jsx(Text, { size: "xs", children: "Pay with confidence using crypto" })] })] })] }) }));
}
function SwapScreenContent(props) {
    const { setScreen, payer, client, toChain, tokenAmount, toToken, fromChain, fromToken, showFromTokenSelector, payOptions, } = props;
    const [receiverAddress, setReceiverAddress] = useState(props.activeAccount.address);
    const { drawerRef, drawerOverlayRef, isOpen, setIsOpen } = useDrawer();
    const [drawerScreen, setDrawerScreen] = useState("fees");
    const fromTokenBalanceQuery = useWalletBalance({
        address: payer.account.address,
        chain: fromChain,
        tokenAddress: isNativeToken(fromToken) ? undefined : fromToken.address,
        client,
    });
    const quoteParams = tokenAmount && !(fromChain.id === toChain.id && fromToken === toToken)
        ? {
            // wallets
            fromAddress: payer.account.address,
            toAddress: receiverAddress,
            // from
            fromChainId: fromChain.id,
            fromTokenAddress: isNativeToken(fromToken)
                ? NATIVE_TOKEN_ADDRESS
                : fromToken.address,
            // to
            toChainId: toChain.id,
            toTokenAddress: isNativeToken(toToken)
                ? NATIVE_TOKEN_ADDRESS
                : toToken.address,
            toAmount: tokenAmount,
            client,
            purchaseData: payOptions.purchaseData,
        }
        : undefined;
    const quoteQuery = useBuyWithCryptoQuote(quoteParams, {
        // refetch every 30 seconds
        staleTime: 30 * 1000,
        refetchInterval: 30 * 1000,
        gcTime: 30 * 1000,
    });
    const sourceTokenAmount = quoteQuery.data?.swapDetails.fromAmount;
    const isNotEnoughBalance = !!sourceTokenAmount &&
        !!fromTokenBalanceQuery.data &&
        Number(fromTokenBalanceQuery.data.displayValue) < Number(sourceTokenAmount);
    const disableContinue = !quoteQuery.data || isNotEnoughBalance;
    const switchChainRequired = props.payer.chain.id !== fromChain.id;
    function getErrorMessage(err) {
        const defaultMessage = "Unable to get price quote";
        try {
            if (err instanceof Error) {
                if (err.message.includes("Minimum")) {
                    const msg = err.message;
                    return msg.replace("Fetch failed: Error: ", "");
                }
            }
            return defaultMessage;
        }
        catch {
            return defaultMessage;
        }
    }
    function showSwapFlow() {
        if (!quoteQuery.data) {
            return;
        }
        setScreen({
            id: "swap-flow",
            quote: quoteQuery.data,
        });
    }
    function showFees() {
        if (!quoteQuery.data) {
            return;
        }
        setIsOpen(true);
        setDrawerScreen("fees");
    }
    const prefillSource = payOptions.buyWithCrypto !== false
        ? payOptions.buyWithCrypto?.prefillSource
        : undefined;
    return (_jsxs(Container, { flex: "column", gap: "md", animate: "fadein", children: [isOpen && (_jsxs(_Fragment, { children: [_jsx(DrawerOverlay, { ref: drawerOverlayRef }), _jsxs(Drawer, { ref: drawerRef, close: () => setIsOpen(false), children: [drawerScreen === "fees" && quoteQuery.data && (_jsxs("div", { children: [_jsx(Text, { size: "lg", color: "primaryText", children: "Fees" }), _jsx(Spacer, { y: "lg" }), _jsx(SwapFees, { quote: quoteQuery.data, align: "left" })] })), drawerScreen === "receiver" && (_jsx(ReceiverWalletDrawerScreen, { client: props.client, onSelect: (x) => setReceiverAddress(x), receiverAddress: receiverAddress, onBack: () => setIsOpen(false) })), drawerScreen === "payer" && (_jsx(WalletSwitcherDrawerContent, { client: client, onSelect: (w) => {
                                    const chain = w.getChain();
                                    const account = w.getAccount();
                                    if (chain && account) {
                                        props.setPayer({
                                            account,
                                            chain,
                                            wallet: w,
                                        });
                                    }
                                }, showAllWallets: !!props.connectOptions?.showAllWallets, wallets: props.connectOptions?.wallets, onBack: () => {
                                    setIsOpen(false);
                                }, onConnect: () => {
                                    setScreen({
                                        id: "connect-payer-wallet",
                                        backScreen: {
                                            id: "buy-with-crypto",
                                        },
                                    });
                                }, selectedAddress: payer.account.address }))] })] })), _jsxs("div", { children: [_jsx(WalletSelectorButton, { client: props.client, onClick: () => {
                            setIsOpen(true);
                            setDrawerScreen("payer");
                        }, address: props.payer.account.address, walletId: props.payer.wallet.id, containerStyle: {
                            borderBottomRightRadius: 0,
                            borderBottomLeftRadius: 0,
                        } }), _jsx(PayWithCrypto, { value: sourceTokenAmount || "", onSelectToken: showFromTokenSelector, chain: fromChain, token: fromToken, isLoading: quoteQuery.isLoading && !sourceTokenAmount, client: client, freezeChainAndTokenSelection: prefillSource?.allowEdits?.chain === false &&
                            prefillSource?.allowEdits?.token === false, payerAccount: props.payer.account }), _jsx(EstimatedTimeAndFees, { quoteIsLoading: quoteQuery.isLoading, estimatedSeconds: quoteQuery.data?.swapDetails.estimated.durationSeconds, onViewFees: showFees }), _jsx(Spacer, { y: "md" }), _jsx(Text, { size: "sm", children: "Send to" }), _jsx(Spacer, { y: "xs" }), _jsx(WalletSelectorButton, { client: props.client, onClick: () => {
                            setIsOpen(true);
                            setDrawerScreen("receiver");
                        }, address: receiverAddress, walletId: undefined })] }), quoteQuery.error && (_jsx(Text, { color: "danger", size: "sm", center: true, children: getErrorMessage(quoteQuery.error) })), switchChainRequired &&
                !quoteQuery.isLoading &&
                !isNotEnoughBalance &&
                !quoteQuery.error ? (_jsx(SwitchNetworkButton, { variant: "accent", fullWidth: true, switchChain: async () => {
                    await props.payer.wallet.switchChain(fromChain);
                } })) : (_jsx(Button, { variant: disableContinue ? "outline" : "accent", fullWidth: true, "data-disabled": disableContinue, disabled: disableContinue, onClick: async () => {
                    if (!disableContinue) {
                        showSwapFlow();
                    }
                }, gap: "xs", children: isNotEnoughBalance ? (_jsx(Text, { color: "danger", children: "Not Enough Funds" })) : quoteQuery.isLoading ? (_jsxs(_Fragment, { children: ["Getting price quote", _jsx(Spinner, { size: "sm", color: "accentText" })] })) : ("Continue") }))] }));
}
function FiatScreenContent(props) {
    const [receiverAddress, setReceiverAddress] = useState(props.payer.account.address);
    const { drawerRef, drawerOverlayRef, isOpen, setIsOpen } = useDrawer();
    const [drawerScreen, setDrawerScreen] = useState("fees");
    const { toToken, tokenAmount, payer, client, setScreen, toChain, showCurrencySelector, selectedCurrency, } = props;
    const buyWithFiatOptions = props.payOptions.buyWithFiat;
    const fiatQuoteQuery = useBuyWithFiatQuote(buyWithFiatOptions !== false && tokenAmount
        ? {
            fromCurrencySymbol: selectedCurrency.shorthand,
            toChainId: toChain.id,
            toAddress: receiverAddress,
            toTokenAddress: isNativeToken(toToken)
                ? NATIVE_TOKEN_ADDRESS
                : toToken.address,
            toAmount: tokenAmount,
            client,
            isTestMode: buyWithFiatOptions?.testMode,
            purchaseData: props.payOptions.purchaseData,
            fromAddress: payer.account.address,
        }
        : undefined);
    function handleSubmit() {
        if (!fiatQuoteQuery.data) {
            return;
        }
        const hasTwoSteps = isSwapRequiredPostOnramp(fiatQuoteQuery.data);
        let openedWindow = null;
        if (!hasTwoSteps) {
            openedWindow = openOnrampPopup(fiatQuoteQuery.data.onRampLink, typeof props.theme === "string" ? props.theme : props.theme.type);
            addPendingTx({
                type: "fiat",
                intentId: fiatQuoteQuery.data.intentId,
            });
        }
        setScreen({
            id: "fiat-flow",
            quote: fiatQuoteQuery.data,
            openedWindow,
        });
    }
    function showFees() {
        if (!fiatQuoteQuery.data) {
            return;
        }
        setDrawerScreen("fees");
        setIsOpen(true);
    }
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    function getErrorMessage(err) {
        const defaultMessage = "Unable to get price quote";
        try {
            if (err.error.code === "MINIMUM_PURCHASE_AMOUNT") {
                const obj = err.error;
                const minAmountUSD = obj.data.minimumAmountUSDCents;
                const currentAmountUSD = obj.data.requestedAmountUSDCents;
                const currentAmountToken = Number(props.tokenAmount);
                const minAmountToken = (minAmountUSD * currentAmountToken) / currentAmountUSD;
                const minAmountTokenWithBuffer = minAmountToken * 1.2; // 20% buffer
                const formattedNum = formatNumber(minAmountTokenWithBuffer, 3);
                return {
                    msg: [`Minimum purchase amount is ${formattedNum}`],
                    minAmount: formattedNum,
                };
            }
        }
        catch { }
        return {
            msg: [defaultMessage],
        };
    }
    const disableSubmit = !fiatQuoteQuery.data;
    // TODO: API should just not return a quote if fromAddress !== toAddress and a swap is required after onramp and return an error message with a specific error id
    // TODO: if the receiver wallet is frozen by the developer, we need to stop the user from clicking continue here
    // Selecting Reciever wallet only allowed if no swap required after onramp
    const enableReceiverSelection = fiatQuoteQuery.data && !isSwapRequiredPostOnramp(fiatQuoteQuery.data);
    const errorMsg = !fiatQuoteQuery.isLoading && fiatQuoteQuery.error
        ? getErrorMessage(fiatQuoteQuery.error)
        : undefined;
    return (_jsxs(Container, { flex: "column", gap: "md", animate: "fadein", children: [isOpen && fiatQuoteQuery.data && (_jsxs(_Fragment, { children: [_jsx(DrawerOverlay, { ref: drawerOverlayRef }), _jsxs(Drawer, { ref: drawerRef, close: () => setIsOpen(false), children: [drawerScreen === "fees" && (_jsxs("div", { children: [_jsx(Text, { size: "lg", color: "primaryText", children: "Fees" }), _jsx(Spacer, { y: "lg" }), _jsx(FiatFees, { quote: fiatQuoteQuery.data })] })), drawerScreen === "receiver" && (_jsx(ReceiverWalletDrawerScreen, { client: props.client, onSelect: (x) => setReceiverAddress(x), receiverAddress: receiverAddress, onBack: () => setIsOpen(false) }))] })] })), _jsxs("div", { children: [_jsx(PayWithCreditCard, { isLoading: fiatQuoteQuery.isLoading, value: fiatQuoteQuery.data?.fromCurrencyWithFees.amount, client: client, currency: selectedCurrency, onSelectCurrency: showCurrencySelector }), _jsx(EstimatedTimeAndFees, { quoteIsLoading: fiatQuoteQuery.isLoading, estimatedSeconds: fiatQuoteQuery.data?.estimatedDurationSeconds, onViewFees: showFees }), _jsx(Spacer, { y: "md" }), _jsx(Text, { size: "sm", children: "Send to" }), _jsx(Spacer, { y: "xs" }), _jsx(WalletSelectorButton, { client: props.client, onClick: () => {
                            setDrawerScreen("receiver");
                            setIsOpen(true);
                        }, address: receiverAddress, disabled: !enableReceiverSelection, walletId: undefined })] }), errorMsg && (_jsx("div", { children: errorMsg.msg.map((msg) => (_jsx(Text, { color: "danger", size: "sm", center: true, multiline: true, children: msg }, msg))) })), errorMsg?.minAmount ? (_jsx(Button, { variant: "accent", fullWidth: true, onClick: () => {
                    props.setTokenAmount(String(errorMsg.minAmount));
                }, children: "Set Minimum" })) : (_jsx(Button, { variant: disableSubmit ? "outline" : "accent", "data-disabled": disableSubmit, disabled: disableSubmit, fullWidth: true, onClick: handleSubmit, gap: "xs", children: fiatQuoteQuery.isLoading ? (_jsxs(_Fragment, { children: ["Getting price quote", _jsx(Spinner, { size: "sm", color: "accentText" })] })) : ("Continue") }))] }));
}
function BuyForTxUI(props) {
    const chainNameQuery = useChainName(props.buyForTx.tx.chain);
    return (_jsxs(Container, { children: [_jsx(Spacer, { y: "xs" }), _jsxs(Container, { flex: "row", style: {
                    justifyContent: "space-between",
                }, children: [_jsx(Text, { size: "sm", children: "Amount Needed" }), _jsxs(Container, { flex: "column", style: {
                            alignItems: "flex-end",
                        }, children: [_jsxs(Container, { flex: "row", gap: "xs", center: "y", children: [_jsxs(Text, { color: "primaryText", size: "sm", children: [props.amountNeeded, " ", props.buyForTx.tokenSymbol] }), _jsx(TokenIcon, { chain: props.buyForTx.tx.chain, client: props.client, size: "sm", token: NATIVE_TOKEN })] }), _jsx(Spacer, { y: "xxs" }), chainNameQuery.name ? (_jsx(Text, { size: "sm", children: chainNameQuery.name })) : (_jsx(Skeleton, { height: fontSize.sm, width: "50px" }))] })] }), _jsx(Spacer, { y: "md" }), _jsx(Line, {}), _jsx(Spacer, { y: "md" }), _jsxs(Container, { flex: "row", style: {
                    justifyContent: "space-between",
                }, children: [_jsx(Text, { size: "sm", children: "Your Balance" }), _jsxs(Container, { flex: "row", gap: "xs", children: [_jsxs(Text, { color: "primaryText", size: "sm", children: [formatNumber(Number(toEther(props.buyForTx.balance)), 4), " ", props.buyForTx.tokenSymbol] }), _jsx(TokenIcon, { chain: props.buyForTx.tx.chain, client: props.client, size: "sm", token: NATIVE_TOKEN })] })] }), _jsx(Spacer, { y: "md" }), _jsx(Line, {}), _jsx(Spacer, { y: "xl" }), _jsx(Text, { center: true, size: "sm", children: "Purchase" }), _jsx(Spacer, { y: "xxs" })] }));
}
function createSupportedTokens(data, payOptions, supportedTokensOverrides) {
    const tokens = {};
    const isBuyWithFiatDisabled = payOptions.buyWithFiat === false;
    const isBuyWithCryptoDisabled = payOptions.buyWithCrypto === false;
    for (const x of data) {
        tokens[x.chain.id] = x.tokens.filter((t) => {
            // it token supports both - include it
            if (t.buyWithCryptoEnabled && t.buyWithFiatEnabled) {
                return true;
            }
            // if buyWithFiat is disabled, and buyWithCrypto is not supported by token - exclude the token
            if (!t.buyWithCryptoEnabled && isBuyWithFiatDisabled) {
                return false;
            }
            // if buyWithCrypto is disabled, and buyWithFiat is not supported by token - exclude the token
            if (!t.buyWithFiatEnabled && isBuyWithCryptoDisabled) {
                return false;
            }
            return true; // include the token
        });
    }
    // override with props.supportedTokens
    if (supportedTokensOverrides) {
        for (const k in supportedTokensOverrides) {
            const key = Number(k);
            const tokenList = supportedTokensOverrides[key];
            if (tokenList) {
                tokens[key] = tokenList;
            }
        }
    }
    return tokens;
}
function ChainSelectionScreen(props) {
    return (_jsx(NetworkSelectorContent, { client: props.client, connectLocale: props.connectLocale, showTabs: false, onBack: props.goBack, chains: props.chains, closeModal: props.goBack, networkSelector: {
            renderChain(renderChainProps) {
                return (_jsx(ChainButton, { chain: renderChainProps.chain, confirming: false, switchingFailed: false, onClick: () => {
                        props.setChain(renderChainProps.chain);
                        props.goBack();
                    }, client: props.client, connectLocale: props.connectLocale }));
            },
        } }));
}
//# sourceMappingURL=BuyScreen.js.map