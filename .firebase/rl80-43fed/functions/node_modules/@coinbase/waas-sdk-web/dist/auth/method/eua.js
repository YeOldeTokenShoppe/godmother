import { AuthMethod } from "../authMethod.js";
import { UserType } from "../util.js";
import { logWarning } from "../../bugsnag.js";
export class EndUserAuthProvider extends AuthMethod {
    type = UserType.EndUserAuth;
    options;
    constructor(options) {
        super(options);
        this.options = { ...options };
    }
    async refresh() {
        try {
            const { authToken, refreshToken } = await this.api.endUserAuth.refreshToken(this.refreshToken);
            if (!authToken) {
                throw new Error("missing `authToken`");
            }
            if (!refreshToken) {
                throw new Error("missing `refreshToken`");
            }
            this.setAuthToken({
                authToken,
                refreshToken,
                endUserId: this.endUserId,
                userType: this.type,
            });
        }
        catch (error) {
            throw new Error("Unable to refresh token: " + error.message, {
                cause: error.cause,
            });
        }
    }
    async login() {
        if (!this.options.projectId) {
            throw new Error("Cannot login user: `projectId` not set");
        }
        const popupURL = new URL(this.hostname + "consumer/login");
        popupURL.searchParams.append("project_id", this.options.projectId);
        const authTokenPromise = registerAuthEventListener(popupURL);
        const loginPopup = window.open(popupURL.toString(), "popup", popupOptions(450, 500));
        try {
            await waitForPopupToClose(loginPopup, 60_000);
        }
        catch (e) {
            if (this.verbose) {
                console.error("Login popup timed out");
            }
            throw new Error("Timed out waiting for user to login");
        }
        let resp;
        try {
            resp = await Promise.race([authTokenPromise, waitForTimeout(2_000)]);
        }
        catch (e) {
            if (this.verbose) {
                console.error("Timed out waiting for auth token from login popup");
            }
            throw new Error("Timed out waiting for auth token from login popup");
        }
        if (!resp) {
            throw new Error("Failed to fetch auth token from popup");
        }
        const { authToken, refreshToken, endUserId, code, message } = resp;
        if (!authToken) {
            throw new Error(`Invalid Auth Token: ${message}`, { cause: `Code: ${code}` });
        }
        this.setAuthToken({ authToken, refreshToken, endUserId, userType: this.type });
    }
    async logout() {
        if (this.authToken) {
            try {
                const { success } = await this.api.endUserAuth.logOut(this.authToken);
                if (!success) {
                    logWarning("Failed to logout user auth token");
                }
            }
            catch (error) {
                logWarning("Error occurred when logging out via end user auth: " + error.message);
            }
        }
        super.logout();
    }
}
function registerAuthEventListener(callbackUrl) {
    let authEventListener;
    return new Promise(resolve => {
        authEventListener = (event) => {
            if (event.origin !== callbackUrl.origin) {
                return;
            }
            if (event.data.type !== "access_token") {
                return;
            }
            resolve(event.data);
        };
        window.addEventListener("message", authEventListener, false);
    }).finally(() => {
        window.removeEventListener("message", authEventListener);
    });
}
function popupOptions(w, h) {
    const left = (window.innerWidth - w) / 2 + window.screenLeft;
    const top = (window.innerHeight - h) / 2 + window.screenTop;
    return `resizable=no,toolbar=no,scrollbars=no,menubar=no,status=no,directories=no,popup=true,height=${h},width=${w},top=${top},left=${left}`;
}
const waitForPopupToClose = (popup, timeoutMs) => {
    if (popup === null) {
        return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
        const timeout = setTimeout(reject, timeoutMs);
        const checkPopup = setInterval(() => {
            if (popup.closed) {
                resolve();
                clearTimeout(timeout);
                clearInterval(checkPopup);
            }
        }, 250);
    });
};
const waitForTimeout = (timeout) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject();
        }, timeout);
    });
};
