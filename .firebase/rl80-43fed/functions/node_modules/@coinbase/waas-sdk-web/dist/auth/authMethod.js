import { WaasCWS } from "../core/cws.js";
import { WaasEndUserAuth } from "../core/enduserauth.js";
import { InMemoryTokenPersistenceStrategy } from "./persistence/memory.js";
import { WaaSInit } from "../core/reinit.js";
const DEFAULT_TTL_SECONDS = 60 * 15;
export class AuthMethod {
    api;
    hostname;
    validUntilMs;
    verbose;
    persistence;
    authToken;
    refreshToken;
    endUserId;
    constructor(options) {
        this.hostname = options.hostname;
        this.verbose = options.verbose ?? false;
        this.validUntilMs = 0;
        this.persistence = options.persistenceStrategy ?? new InMemoryTokenPersistenceStrategy();
        const token = this.persistence.get();
        if (token && token.contents) {
            this.setAuthToken(token.contents, token.validUntil.getTime());
        }
    }
    async maybeRefresh(force = false) {
        if (!force) {
            if (Date.now() < this.validUntilMs) {
                return;
            }
        }
        await this.refresh();
    }
    async logout() {
        this.persistence.clear();
        this.validUntilMs = 0;
        this.authToken = undefined;
        this.refreshToken = undefined;
        this.endUserId = undefined;
        this.api = undefined;
    }
    setAuthToken(token, validUntil) {
        if (!token.authToken) {
            throw new Error("Malformed auth token: missing `authToken`");
        }
        this.api = {
            cws: new WaasCWS({
                hostname: this.hostname,
                verbose: this.verbose,
                onAuthExpired: () => this.maybeRefresh(true),
                authToken: token.authToken,
            }),
            reinit: new WaaSInit({
                hostname: this.hostname,
                verbose: this.verbose,
                onAuthExpired: () => this.maybeRefresh(true),
                authToken: token.authToken,
            }),
            endUserAuth: new WaasEndUserAuth({
                hostname: this.hostname,
                verbose: this.verbose,
                authToken: token.authToken,
            }),
            ops_key: token.authToken,
        };
        token.userType = this.type;
        if (!validUntil) {
            this.persistence.update(token, DEFAULT_TTL_SECONDS);
        }
        this.authToken = token.authToken;
        this.refreshToken = token.refreshToken;
        this.endUserId = token.endUserId;
        this.validUntilMs = validUntil ? validUntil : Date.now() + DEFAULT_TTL_SECONDS * 1000;
    }
}
