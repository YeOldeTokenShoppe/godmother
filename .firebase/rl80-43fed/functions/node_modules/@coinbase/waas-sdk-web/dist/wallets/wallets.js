var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var WalletsImpl_1;
import { ProtocolFamily } from "../index.js";
import { AuthImpl } from "./../auth/auth.js";
import { MPC } from "../mpc.js";
import { RequireAuth, StaticImplements } from "../utils.js";
import { WaasImpl } from "../waas.js";
import { WalletImpl, NewWalletImpl, assertPasscodeValid } from "./wallet.js";
import { EVM_PATH_INDEX_0, createMPCWallet, doesContainerExist, restoreMPCWallet, getMPCPublicKeyInfo, } from "../core/mpc.js";
import { PerformanceSensitive } from "../perf.js";
import { AddressesImpl } from "./addresses.js";
import { encryptBackup, getHostedBackup } from "./backups.js";
import { logError, logWarning } from "../bugsnag.js";
const assertHasWallet = (hasWallet) => {
    if (!AuthImpl.user) {
        console.warn("issueAuthToken is deprecated. Please migrate to issueUserToken!");
    }
    if (AuthImpl.user?.hasWallet !== undefined && AuthImpl.user?.hasWallet !== hasWallet) {
        throw new Error(`Expected the user to ${hasWallet ? "have" : "not have"} a wallet already.`);
    }
};
let WalletsImpl = class WalletsImpl {
    static { WalletsImpl_1 = this; }
    static wallet;
    static apiProvider;
    static options;
    static get api() {
        return this.apiProvider.api;
    }
    static async create(passcode) {
        assertPasscodeValid(passcode);
        assertHasWallet(false);
        if (WalletsImpl_1.getWallet()) {
            const error = new Error("a valid wallet already exists. you need to log out before creating another");
            logWarning(error);
            throw error;
        }
        try {
            const activationString = await createMPCWallet(this.api.ops_key, passcode);
            const pubkeyInfo = await getMPCPublicKeyInfo(this.api.ops_key, EVM_PATH_INDEX_0);
            const newWallet = new NewWalletImpl(this, pubkeyInfo.rootContainerID, AuthImpl.user.id, activationString);
            let backupData;
            if (this.options.enableHostedBackups) {
                backupData = await encryptBackup(activationString);
            }
            WalletsImpl_1.setWallet(newWallet);
            await AddressesImpl.getAddress(ProtocolFamily.EVM, 0, backupData);
            return newWallet;
        }
        catch (e) {
            const error = new Error("Unable to create wallet: " + e.message, {
                cause: e.cause,
            });
            logError(error);
            throw error;
        }
    }
    static async getLocalWalletCache() {
        const localWalletStr = await MPC.getLocalWallet();
        if (!localWalletStr) {
            return null;
        }
        try {
            const localWallet = JSON.parse(localWalletStr);
            return new WalletImpl(this, localWallet.rootContainerID, localWallet.endUserID);
        }
        catch {
            try {
                await WaasImpl.finalize();
            }
            catch { }
            return null;
        }
    }
    static async fetchWallet() {
        var walletQuery;
        try {
            walletQuery = await WalletsImpl_1.api.cws.getWallet();
            return walletQuery;
        }
        catch (e) {
            if (e.cause?.status === 404) {
                return undefined;
            }
            throw e;
        }
    }
    static async activeMPCWallet(user) {
        if (!(await doesContainerExist())) {
            return null;
        }
        const pubkeyInfo = await getMPCPublicKeyInfo(WalletsImpl_1.api.ops_key, EVM_PATH_INDEX_0);
        const rootContainerID = pubkeyInfo.rootContainerID;
        return new WalletImpl(WalletsImpl_1, rootContainerID, user.id);
    }
    static async resume(user) {
        try {
            user.hasWallet = false;
            let [cachedWallet, activeMPCWallet] = await Promise.all([
                this.getLocalWalletCache(),
                this.activeMPCWallet(user),
            ]);
            let cachedWalletIsValidAndBelongsToUser = cachedWallet?.endUserID === user.id && !!user.id && !!cachedWallet.rootContainerID;
            if (!cachedWalletIsValidAndBelongsToUser) {
                const [walletQuery] = await Promise.all([this.fetchWallet(), WaasImpl.finalize()]);
                user.hasWallet = !!walletQuery?.wallet?.keyContainerRootId;
                return null;
            }
            user.hasWallet = true;
            if (cachedWallet.rootContainerID &&
                cachedWallet.rootContainerID === activeMPCWallet?.rootContainerID) {
                WalletsImpl_1.setWallet(cachedWallet);
                return cachedWallet;
            }
            await WaasImpl.finalize();
            return null;
        }
        catch (e) {
            const error = new Error("Unable to resume wallet: " + e.message, {
                cause: e.cause,
            });
            logError(error);
            throw error;
        }
    }
    static async restoreFromHostedBackup(passcode, protocolFamily = ProtocolFamily.EVM) {
        assertHasWallet(true);
        let backup = await getHostedBackup(this.api, passcode, protocolFamily);
        return await this.restoreFromBackup(backup, passcode);
    }
    static async restoreFromBackup(backup, passcode) {
        assertPasscodeValid(passcode);
        assertHasWallet(true);
        if (WalletsImpl_1.getWallet()) {
            const error = new Error("a valid wallet already exists. you need to log out before restoring another wallet");
            logWarning(error);
            throw error;
        }
        try {
            await restoreMPCWallet(this.api.ops_key, passcode, backup);
            const pubkeyInfo = await getMPCPublicKeyInfo(this.api.ops_key, EVM_PATH_INDEX_0);
            const wallet = new WalletImpl(this, pubkeyInfo.rootContainerID, AuthImpl.user.id);
            WalletsImpl_1.setWallet(wallet);
            await AddressesImpl.all();
            return wallet;
        }
        catch (e) {
            const error = new Error("Unable to restore the wallet: " + e.message, {
                cause: e.cause,
            });
            logError(error);
            throw error;
        }
    }
    static finalize() {
        MPC.removeLocalWallet();
        WalletsImpl_1.wallet?.finalize();
        WalletsImpl_1.wallet = undefined;
    }
    static getWallet() {
        return WalletsImpl_1.wallet;
    }
    static setWallet(wallet) {
        WalletsImpl_1.wallet = wallet;
        MPC.setLocalWallet(JSON.stringify(wallet));
    }
};
__decorate([
    PerformanceSensitive,
    RequireAuth
], WalletsImpl, "create", null);
__decorate([
    PerformanceSensitive,
    RequireAuth
], WalletsImpl, "resume", null);
__decorate([
    PerformanceSensitive,
    RequireAuth
], WalletsImpl, "restoreFromHostedBackup", null);
__decorate([
    PerformanceSensitive,
    RequireAuth
], WalletsImpl, "restoreFromBackup", null);
WalletsImpl = WalletsImpl_1 = __decorate([
    StaticImplements()
], WalletsImpl);
export { WalletsImpl };
