import { WAAS_ENV } from "../waas.js";
import { hexToBuffer, utf8ToBuffer, base64ToBuffer, bufferToHex } from "./buffer.js";
import { ProtocolFamily } from "../networks.js";
import { UUIDHelper } from "../utils.js";
const KEK_PUBLIC_KEYS = {
    LOCAL: "-----BEGIN PUBLIC KEY-----\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA6GEE3vq3DbJfwqFervhr\nur1yoVLaC4VNR4WWdsKVtdz8Sf0MuCO9UQ0IHxQuPoujNEKdyv5QTwtDQCAxg0CT\nWJL501BLizovYgDfOl69PxCUJXpoNi47T2tf8xcK7iNuW/aP9/ru0a/KtBejO+gi\n0WxxeyhlBA0E4NQX4nD0knRX2mcqRwMPgM/LjITB9vuSHpa5ojiePhS8Fw9uZP4h\n73WhShPJbCWQrfpBamFI2yFZfy36BRHRMeOWCxPjVzZ1hgxNvHUY0hml9DG6vUoj\nqAQjgaSEPVy5ATPJZrMcaPqnHsc3LK53XGP1NBtEeJhpIHJvIjguEniVimOPe2w0\nNrr5AJ/30Nl8rEPCX7nRgfEFEpiLB+oBfflP8xNswnBs5606280rrhb86AJHJ+Kg\n8yr8NCdDvLRacRRtrysuGXpXCWg4nCdCV79Y822mts6i7oKKjtt5dDoErrmhmp90\nlSICFL+EdDqd0BKRKeMh5bJGXALx+PPTo+Q3eL5cEZtIA1IYv171YqJKcRkxyA8t\n/eoNuW/x7VP1QtJW16FnKEgsi4cMda8dPg9CcsUaVAM17kxuvmLVagTsqEaK7gVE\nlo7AacEXbNyw6jDFpQvTfrZmrBJfiY6ADNcbdMqGp+N8vhDKabriQhpSViUzsDh+\nBzKwK1AOI7772EaZq5Wg70MCAwEAAQ==\n-----END PUBLIC KEY-----",
    DEV: "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsBAOZjbvTapSgWa3Mf6N\niKvbKjc4NswMOppfqdcn/UB5T9PIj3/AtSHRGgwhlJLYEzOXEJuQ54QqXqMneSB0\najO/PeopxGdvWJd/DaQPKxbOzPMBqYuGkk+wu2QMqH1n5ymIdA3wCjzurJyfE+4R\nwBfBvuPFF3ymxSf9NVEAax/wkKmLDp3WhfN2nCgfn1CKOoscA7/muKRKcD1R8FCD\nqkNW/Ndg7SkPoxodjtlUNepMgIVjWudiV7buFsVgzGCp3IeNJ0obPEKwTJmgstQb\n7TPc2SjQdm79FGc8FA9hZ9hGVDWJrlnqWV4ifSkllGswr1GVB0QYfdA2muXcAP84\nUQIDAQAB\n-----END PUBLIC KEY-----",
    STAGING: "-----BEGIN PUBLIC KEY-----\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAxQI0jTNT/fWZdnXx650m\nLkjLkgOf7qRMpm/lVjk7QIm95DCnAkHYJfCDLiP/iP+WdGTSrLPv4nQ/IBWb8DPF\n0V8XcrhiTb1HwImOGus4ORQYj5SyBE0IRz3XwyleMqByZTV1Ccvb8IJogtkYio36\nB9IXa798KqDsaOLynT0K7EzDNLPa+Ckl4Y/KilO/ojmTyM92Qde5bsZMYEjpIPjK\nah+KSWb5jqrA59WxhKUWJIBDJPApP8HVuy5WiinERPOQHskGW/NkDu5fI3oEtALc\nIyYykba4jhZJvBCp/njYjtgPjdlGT+0mw+0c0U4V1JbUEQvOVTxtHscUOnmv4bYh\notNJqrSLmF+U+m/bYkfgHPmDSjQl5rjHbDoVSr+a1DWAGCwSXCDuxokvzi6CaWvy\ne0Xp4n0W9PC+8jGJRHRGf54lsykCrtq2wVe4UEqmlpFEeol4+ShBw9ts1ZcPefvY\nJENsEIIwyLnJbpbzwaczp4m8wBlmTX9ZDli/Xz94vi+s9mF2WRUr0Yocc7aSDDus\nxJKfbSuz0Xv4L2SxnBYaYNmISC/YlcUmisuHsS0JNM3yCPdan0h4WB6bdZCKgSwS\nif/tIPZ52IXq5j3tRNCrsUqfIyVjOBgrU1TQKyRDGrF8Q5V+6HultAyM196+G9Vi\nCrRPOThq0dhhUplgbsOeiocCAwEAAQ==\n-----END PUBLIC KEY-----",
    PROD: "-----BEGIN PUBLIC KEY-----\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAx49k8Zf9Oi2QrmNwFJV6\n2VuXAwyb1NuZX2d7wD2vY7Gw0qZQZ4DusUVYm9kdwVL3wH2Gjvs4Obg9SZCeIiif\nyfh+pXtTz6xBYaloZnErNSttzuAW0tdvWou9WgJzcaWYHUxCcVQNJDQyUIqtD2Iw\nfZImC6ShAO1+ewRin0G9t3OkngHX4StzGXpCs0/4632VKxvIMfzHCGyZbP1spYkX\nEKl7L4VREFu0xZOAm+1OtY1duiguKjyKbFOiUM/7ICbL855AWFVJVgVY9Ua4q7J6\nqj7GTV8dNLdpez3e2O1upgDTkpm7qA2fBDZuFi+0BBh1vUG2n6sPiZ9ZTinSUGIo\n+4PnRATeuvmQolKTJPjhEBCzAYmkt6WHCi7bw2HNRGaDJhpwN3tvHCGQ2WlpauzI\n0UPq7fUrMB7H/fUXfgveFqpfkXAAPRVeLJEWU+2Z0UMZCxVJlOAL0KOOzW7jh9WB\nZpfE4LC634aFEPoNbkEDm7QEQkjlj5qTtSnqvjglOy3qUY3IVr9lNkTS2I4HHKO0\nI4TxvhFyvXdHKVtgrWuGa29UEMLsehBuhjl5BTba3Vcl8HUV8gq42gfaHP6JGdwb\nIfxlxDHECobew4TD1Ms5W+a1lwjwgZqYJfRNpCBIryxYv2D2eTk93FlG+U4n/Q5S\nArAWjFRAB/V4z4elID0wu+0CAwEAAQ==\n-----END PUBLIC KEY-----",
};
const KEK_PUBLIC_KEY_HASHES = {
    LOCAL: "82dfd3b7ed1412fdae2ae84d47c1ec0e52f16ce946f2989cae10eeecda05db9a",
    DEV: "fed4a611c4d2db3cc67197a180a9f052a9fb29d5f42e0363c4628c7274c0a7d6",
    STAGING: "8b2de53eb4ad229875c1ea86bb99dc3e5239ccce981b0b9477ffb73e8c837852",
    PROD: "d01fb235a96e8c278ecd6d7ef776a9a58ab917300b0c768fe080dfcf92450fcf",
};
const importRsaKey = pem => {
    const pemHeader = "-----BEGIN PUBLIC KEY-----";
    const pemFooter = "-----END PUBLIC KEY-----";
    const pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length - 1);
    const binaryDerString = base64ToBuffer(pemContents);
    return window.crypto.subtle.importKey("spki", binaryDerString, {
        name: "RSA-OAEP",
        hash: "SHA-256",
    }, false, ["encrypt"]);
};
export async function recoverActivationString(encryptedActivationString, ivHex, dekHex) {
    const dekBytes = hexToBuffer(dekHex);
    const dek = await window.crypto.subtle.importKey("raw", dekBytes, {
        name: "AES-GCM",
        length: 256,
    }, false, ["decrypt"]);
    const result = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: hexToBuffer(ivHex) }, dek, hexToBuffer(encryptedActivationString));
    return bufferToHex(result);
}
async function generateDek() {
    const dek = await window.crypto.subtle.generateKey({
        name: "AES-GCM",
        length: 256,
    }, true, ["encrypt", "decrypt"]);
    const exported = await window.crypto.subtle.exportKey("raw", dek);
    return { hex: bufferToHex(exported), dek };
}
export async function encryptBackup(backup) {
    if (!window.SubtleCrypto || !window.crypto.subtle) {
        throw new Error("Unsupported browser.");
    }
    try {
        const { cipherText, iv, sessionKey } = await encryptData(backup);
        return {
            encryptedActivationStringHex: bufferToHex(cipherText),
            ivHex: bufferToHex(iv),
            sessionKeyHex: bufferToHex(sessionKey),
            kekPublicKeyHash: KEK_PUBLIC_KEY_HASHES[WAAS_ENV],
        };
    }
    catch (exc) {
        console.error(exc);
        throw new Error("encountered an error while backing up your wallet", { cause: exc });
    }
}
export async function getHostedBackup(api, passcode, protocolFamily = ProtocolFamily.EVM) {
    const correlationId = UUIDHelper.GenerateUUID();
    const { wallet } = await api.cws.withCorrelationId(correlationId).getWallet();
    if (!wallet) {
        throw new Error("no wallet for user.");
    }
    const { reinitializationMetadata } = wallet;
    if (!reinitializationMetadata || reinitializationMetadata.sessionKeyHex === "") {
        throw new Error("no backup found.");
    }
    const dek = await api.reinit
        .withCorrelationId(correlationId)
        .decryptSessionKey(reinitializationMetadata.sessionKeyHex);
    const backup = await recoverActivationString(reinitializationMetadata.encryptedActivationStringHex, reinitializationMetadata.ivHex, dek);
    await updateWalletReinitMetadata(api, wallet, backup);
    return backup;
}
export async function updateWalletReinitMetadata(api, wallet, backup) {
    const { cipherText, iv, sessionKey } = await encryptData(backup);
    let updatedEncryptedActivationStringHex = bufferToHex(cipherText);
    let updatedIvHex = bufferToHex(iv);
    let updatedSessionKeyHex = bufferToHex(sessionKey);
    if (!wallet.reinitializationMetadata) {
        throw new Error("no wallet reinitializationMetadata found");
    }
    wallet.reinitializationMetadata.ivHex = updatedIvHex;
    wallet.reinitializationMetadata.sessionKeyHex = updatedSessionKeyHex;
    wallet.reinitializationMetadata.encryptedActivationStringHex =
        updatedEncryptedActivationStringHex;
    let updatedWallet = await api.cws.updateWalletReinitMetadata(wallet);
    if (!updatedWallet) {
        throw new Error("unable to update wallet");
    }
    return;
}
async function encryptData(backup) {
    const { dek, hex } = await generateDek();
    const iv = window.crypto.getRandomValues(new Uint8Array(12));
    const kek = await importRsaKey(KEK_PUBLIC_KEYS[WAAS_ENV]);
    const [cipherText, sessionKey] = await Promise.all([
        window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, dek, hexToBuffer(backup)),
        window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, kek, utf8ToBuffer(hex)),
    ]);
    return { cipherText, iv, sessionKey, hex };
}
