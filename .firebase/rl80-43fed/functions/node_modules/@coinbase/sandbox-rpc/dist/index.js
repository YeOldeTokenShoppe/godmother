import { log, getTargetInfo } from "./utils.js";
import { state, setLoading } from "./globals.js";
import { coreDidReceiveMessage, coreReceive } from "./core.js";
import { delegateCallToCore, clientDidReceiveMessage } from "./client.js";
import { IS_CLIENT, IS_DEBUG, IS_SANDBOX } from "./config.js";
import { createFrame } from "./frame.js";
export function sandboxInit(options) {
    if (process.env.TSIFRPC_DISABLED === "1") {
        return;
    }
    log(`Sandbox Init (client=${IS_CLIENT}`);
    state().version = options.version;
    if (IS_CLIENT) {
        state().targetOrigin = new URL(options.sandbox).origin;
        const iframe = createFrame(options);
        document.body.appendChild(iframe);
        state().frame = iframe.contentWindow;
        setLoading(new Promise(resolve => {
            iframe.onload = function (_) {
                log("Frame initialized.");
                resolve();
            };
            setLoading(null);
        }));
        log(`Client initialized: (sandbox=${state().targetOrigin})`);
    }
    else {
        state().frame = window.parent;
        if (window.location.ancestorOrigins &&
            !window.location.ancestorOrigins[0] &&
            !document.referrer) {
            displayMessage("invalid embedding -- are you viewing the page directly?");
            return;
        }
        state().targetOrigin = window.location.ancestorOrigins
            ? window.location.ancestorOrigins[0]
            : new URL(document.referrer).origin;
        if (state().targetOrigin.startsWith("https://localhost") ||
            state().targetOrigin.startsWith("https://localhost")) {
            displayMessage("local embedded sandbox!");
        }
        else {
            displayMessage("deployed embedded sandbox!");
        }
        log(`Sandbox initialized: (referrer=${state().targetOrigin})`);
    }
    attachListener();
}
const displayMessage = (msg) => {
    const loaded = document.createElement("p");
    loaded.innerHTML = msg;
    document.body.appendChild(loaded);
};
const attachListener = () => {
    if (!state().listener) {
        state().listener = event => {
            if (event.origin !== state().targetOrigin) {
                log(`Received event from ${event.origin}. Dismissing (expected ${state().targetOrigin})`);
                return;
            }
            log("received message");
            log(event.data);
            if (IS_CLIENT) {
                clientDidReceiveMessage(event);
            }
            else {
                coreDidReceiveMessage(event);
            }
        };
        window.addEventListener("message", state().listener, false);
    }
};
export function runInSandboxWithOptions(options) {
    if (process.env.TSIFRPC_DISABLED === "1") {
        return;
    }
    if (IS_SANDBOX && !state().frame) {
        if (!process?.env?.TSIFRPC_CLASS_VERSION) {
            throw new Error("TSIFRPC_CLASS_VERSION unset. Please set during build.");
        }
        sandboxInit({
            sandbox: window.origin,
            debug: process?.env?.DEBUG == "1",
            version: process?.env?.TSIFRPC_CLASS_VERSION,
        });
    }
    return (target, propertyKey, descriptor) => {
        if (!propertyKey) {
            throw new Error("rpcAvailable only available in `method` context.");
        }
        const [clazzName, isStatic] = getTargetInfo(target);
        if (!isStatic) {
            throw new Error("runInSandbox only available in `static` context.");
        }
        if (!target.__rpc) {
            target.__rpcStatic = isStatic;
            target.__rpc = {};
            target.__dispatch = {};
            if (!state().dispatch.minifiedClazzNames[clazzName]) {
                state().dispatch.minifiedClazzNames[clazzName] = Object.keys(state().dispatch.minifiedClazzNames).length;
            }
            target.__minifiedClazzname = state().dispatch.minifiedClazzNames[clazzName];
            state().dispatch.staticDispatch[target.__minifiedClazzname] = target;
            if (IS_DEBUG) {
                log(`[CLASS] ${clazzName} => ${target.__minifiedClazzname} (static=${isStatic})`);
                log(state().dispatch.minifiedClazzNames);
            }
        }
        const assignedName = `${Object.keys(target.__rpc).length}`;
        target.__rpc[assignedName] = propertyKey;
        if (IS_DEBUG) {
            log(`[FUNC] ${propertyKey} => ${assignedName}`);
        }
        overrideInstanceOrStaticMethod(descriptor, target, assignedName, options);
    };
}
export const runInSandbox = runInSandboxWithOptions();
function overrideInstanceOrStaticMethod(descriptor, target, assignedName, options) {
    if (IS_CLIENT) {
        descriptor.value = delegateCallToCore(target, assignedName, options);
    }
    else {
        if (!target.__recv) {
            target.__recv = coreReceive;
        }
        if (!target.__args) {
            target.__args = {};
        }
        target.__args[assignedName] = descriptor.value.length;
    }
}
