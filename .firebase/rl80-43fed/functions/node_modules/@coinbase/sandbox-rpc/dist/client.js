import { getTargetInfo, log, logError } from "./utils.js";
import { state, assureLoaded, getNonce } from "./globals.js";
const awaitReplyForTarget = (options) => {
    return nonce => {
        log(`[${nonce}] Awaiting a reply`);
        const data = {
            resolve: null,
            reject: null,
            prom: null,
        };
        const prom = new Promise((resolve, reject) => {
            data.resolve = resolve;
            data.reject = reject;
        }).finally(() => {
            state().dispatch.globalDispatch[nonce] = undefined;
        });
        data.prom = prom;
        state().dispatch.globalDispatch[nonce] = data;
        const timeout = options?.timeoutMs || 15000;
        setTimeout(() => {
            if (state().dispatch.globalDispatch[nonce] !== undefined) {
                logError(`[${nonce}] Request timed out.`);
                state().dispatch.globalDispatch[nonce] = undefined;
            }
        }, timeout);
        return prom;
    };
};
export const delegateCallToCore = (target, callName, options) => {
    const awaitReply = awaitReplyForTarget(options);
    const [clazzName] = getTargetInfo(target);
    return (...args) => {
        const minifiedClass = state().dispatch.minifiedClazzNames[clazzName];
        const message = {
            nonce: getNonce(),
            name: callName,
            args: args,
            class: `${minifiedClass}`,
            version: state().version,
        };
        return assureLoaded().then(() => {
            log(`Invoking ${minifiedClass}/${clazzName}.${callName}() via message (below) (to=${state().targetOrigin})}`);
            log(message);
            setTimeout(() => {
                state().frame.postMessage(message, state().targetOrigin);
            }, 0);
            return awaitReply(message.nonce);
        });
    };
};
export const clientDidReceiveMessage = event => {
    const message = event.data;
    if (message.nonce == undefined || message.nonce == null) {
        log("Ignoring message.");
        return;
    }
    const listener = state().dispatch.globalDispatch[message.nonce];
    if (!listener) {
        logError(`Invalid nonce: ${message.nonce}`);
        return;
    }
    if (message.error) {
        listener.reject(message.error);
    }
    else {
        listener.resolve(message.value);
    }
};
