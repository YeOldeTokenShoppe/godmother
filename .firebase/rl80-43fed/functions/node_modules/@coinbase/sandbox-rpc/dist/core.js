import { log, logError } from "./utils.js";
import { state } from "./globals.js";
const reply = (nonce, value, error) => {
    const message = { nonce: nonce, value: value, error: error };
    state().frame.postMessage(message, state().targetOrigin);
};
export const coreReceive = (nonce, name, minifiedClazz, args) => {
    const receiver = state().dispatch.staticDispatch[minifiedClazz];
    if (!receiver) {
        logError(`Unknown class receiver ${minifiedClazz}`);
        logError(`supported receivers: `);
        logError(JSON.stringify(state().dispatch.minifiedClazzNames));
        logError(state().dispatch.staticDispatch);
        reply(nonce, null, new Error(`unknown receiver ${minifiedClazz}`));
        return;
    }
    const propName = receiver.__rpc[name];
    log(`Received request for function ${name} (nonce=${nonce}, propName=${propName}, name=${name})`);
    const prop = receiver[propName];
    if (!prop) {
        logError(`Unknown function ${propName} (originally ${name}) available functions:`);
        logError(receiver.__rpc);
        reply(nonce, null, new Error(`unknown invocation ${minifiedClazz}.${propName}`));
        return;
    }
    if (receiver.__args[name] !== args.length) {
        logError(`Function ${propName} expected ${receiver.__args[name]} args, but received ${args.length}`);
        reply(nonce, null, new Error(`invalid invocation ${minifiedClazz}.${propName}`));
        return;
    }
    try {
        const retVal = prop.call(receiver, ...args);
        if (retVal instanceof Promise) {
            retVal
                .then(res => {
                reply(nonce, res);
            })
                .catch(exc => {
                reply(nonce, null, new Error(`error: ${exc}`));
            });
        }
        else {
            reply(nonce, retVal);
        }
    }
    catch (exc) {
        reply(nonce, null, new Error(`error: ${exc}`));
    }
};
export const coreDidReceiveMessage = event => {
    const message = event.data;
    if (message.version !== state().version) {
        logError(`incorrect version`);
        logError("This may happen if local work has not been rebuilt (via tsc) in @coinbase/waas-sdk-web, or in sandbox-rpc.");
        logError("If this happens in production, this is in an incident.");
        reply(`${message.nonce}`, null, new Error(`invalid rpc version (client=${message.version}, sandbox=${state().version})`));
        return;
    }
    coreReceive(message.nonce, message.name, message.class, message.args);
};
