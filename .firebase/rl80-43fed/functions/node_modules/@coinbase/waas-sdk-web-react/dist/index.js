import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useEffect, useState } from "react";
import { ProtocolFamily } from "@coinbase/waas-sdk-web";
import { useDisallowStrictMode } from "./utils.js";
import * as WaaS from "@coinbase/waas-sdk-web";
const WaasContext = createContext({
    waas: undefined,
    user: undefined,
    wallet: undefined,
    error: undefined,
    isCreatingWallet: false,
    isLoggingIn: false,
});
/**
 * A provider for injecting the WalletContext into a react app.
 *
 * @param options See {@link TProviderOptions}
 * @returns A JSX node for injecting the wallet provider.
 *
 * @example
 *
 * // 1. Logging in a user and creating a wallet with interaction
 * ```
 *  <WalletProvider>
 *    <MyComponent />
 *  </WalletProvider>
 *
 *  const MyComponent = () => {
 *    const { waas, user, wallet, isLoggingIn, isCreatingWallet } = useWalletContext();
 *    if (!waas) {
 *      return <Loading />
 *    }
 *    if (!user) {
 *      const provideAuthToken = async (): string => {
 *        // fetch a new auth token from your server.
 *      };
 *      return <button onClick={() => waas.login({ provideAuthToken })} disabled={isLoggingIn}>Login</button>
 *    }
 *    if (!wallet) {
 *       return <button onClick={() => user.create()} disabled={isCreatingWallet}>Create Wallet</button>
 *    }
 *    return <p>Wallet created.</p>
 *  }
 * ```
 * // 2. Automatically login and auto-create a wallet on start
 * ```
 *  <WalletProvider autoCreateWallet={true}>
 *    <MyComponent />
 *  </WalletProvider>
 *
 *  const MyComponent = () => {
 *    const { waas, user, wallet, isLoggingIn, isCreatingWallet } = useWalletContext();
 *    useEffect(() => {
 *      // If WaaS is not initialized, the user is logged in, or the user is already logging in, do nothing.
 *      if (!waas || user || isLoggingIn) return;
 *      const provideAuthToken = async (): string => {
 *        // fetch a new auth token from your server.
 *      };
 *      waas.login({ provideAuthToken });
 *    }, [waas, user, isLoggingIn]);
 *    if (isCreatingWallet) {
 *      return <Loading />;
 *    }
 *    if (wallet) {
 *      // do something with the wallet.
 *    }
 *  }
 * ```
 */
export function WalletProvider(options) {
    const [waasWrapper, setWaasWrapper] = useState(undefined);
    const [rawUser, setRawUser] = useState(undefined);
    const [user, setUser] = useState();
    const [isLoggingIn, setIsLoggingIn] = useState(false);
    const [isCreatingWallet, setIsCreatingWallet] = useState(false);
    const [wallet, setWallet] = useState();
    const [error, setError] = useState();
    useDisallowStrictMode();
    const restoreFromBackup = useCallback(async (backup, passcode) => {
        if (!waasWrapper) {
            throw new Error("User is not yet logged in.");
        }
        setIsCreatingWallet(true);
        const wallet = await waasWrapper.waas.wallets
            .restoreFromBackup(backup, passcode)
            .then(wallet => {
            setWallet(wallet);
            return wallet;
        })
            .finally(() => setIsCreatingWallet(false));
        return wallet;
    }, [waasWrapper]);
    const restoreFromHostedBackup = useCallback(async (passcode) => {
        if (!waasWrapper) {
            throw new Error("User is not yet logged in.");
        }
        if (!options.enableHostedBackups) {
            throw new Error("Hosted backups are not enabled.");
        }
        setIsCreatingWallet(true);
        const wallet = await waasWrapper.waas.wallets
            .restoreFromHostedBackup(passcode)
            .then(wallet => {
            setWallet(wallet);
            return wallet;
        })
            .finally(() => setIsCreatingWallet(false));
        return wallet;
    }, [waasWrapper, setWallet, setIsCreatingWallet]);
    const createWallet = useCallback(async (passcode) => {
        if (!waasWrapper) {
            throw new Error("Waas is not yet initialized.");
        }
        setIsCreatingWallet(true);
        const wallet = await waasWrapper.waas.wallets
            .create(passcode)
            .then(wallet => {
            setWallet(wallet);
            return wallet;
        })
            .finally(() => setIsCreatingWallet(false));
        return wallet;
    }, [waasWrapper, setIsCreatingWallet, setWallet]);
    const login = useCallback(async (loginOptions) => {
        if (!waasWrapper) {
            throw new Error("Waas is not yet initialized.");
        }
        if (user) {
            throw new Error("User is already logged in.");
        }
        if (isLoggingIn) {
            throw new Error("Cannot login while already logging in.");
        }
        setIsLoggingIn(true);
        // Login the user. When this resolves the wevb `waas` instance will be
        // ready to use for authenticated requests.
        const waasUser = await waasWrapper.waas.auth
            .login(loginOptions)
            .finally(() => setIsLoggingIn(false));
        const newUser = {
            restoreFromBackup,
            create: createWallet,
            restoreFromHostedBackup: options.enableHostedBackups ? restoreFromHostedBackup : undefined,
            hasWallet: waasUser.hasWallet,
        };
        setUser(newUser);
        setWallet(waasWrapper.waas.wallets.wallet);
        return newUser;
    }, [waasWrapper, user, isLoggingIn, setIsLoggingIn]);
    const logout = useCallback(async () => {
        setIsLoggingIn(true);
        await WaaS.Logout().finally(() => setIsLoggingIn(false));
        setWallet(undefined);
        setUser(undefined);
    }, [waasWrapper, isLoggingIn]);
    // Initialize Waas on first load.
    // This resolves the initialization promise so that the login function can
    // properly evaluate with the `waas` instance.
    useEffect(() => {
        WaaS.InitializeWaas(options)
            .then(waas => {
            setWaasWrapper({ waas });
            setRawUser(waas.auth.user);
            return waas;
        })
            .catch(exc => setError(exc));
    }, [setWaasWrapper, setError]);
    // When the `setUser` call is done after the `InitializeWaas` promise, the `createWallet` callback
    // function seems to not be updated with the appropriate `WaasWrapper`.
    // Moving this into a `useEffect` allows this to updated after the `waasWrapper` state is set.
    useEffect(() => {
        if (waasWrapper && rawUser) {
            const newUser = {
                restoreFromBackup,
                create: createWallet,
                restoreFromHostedBackup: options.enableHostedBackups ? restoreFromHostedBackup : undefined,
                hasWallet: rawUser.hasWallet,
            };
            setUser(newUser);
            setWallet(waasWrapper.waas?.wallets?.wallet);
        }
    }, [rawUser, waasWrapper]);
    return (_jsx(WaasContext.Provider, { value: {
            waas: waasWrapper ? { login, logout } : undefined,
            user,
            isCreatingWallet,
            isLoggingIn,
            wallet,
            error,
        }, children: options.children }));
}
/**
 * A hook for using an MPC wallet, in a component that is already wrapped in the WalletProvider.
 *
 *
 * @param options See {@link @coinbase/waas-sdk-web#InitializeWaasOptions}
 * @returns The {@link @coinbase/waas-sdk-web#Waas} instance, and a wallet.
 *
 *  This must be used within a {@link WalletProvider}.
 *
 *  e.g
 * ```
 *    <WalletProvider>
 *      <MyComponent />
 *    </WalletProvider>
 *
 *    //...
 *
 *  const MyComponent = () => {
 *     const {wallet, isCreatingWallet} = useWalletContext();
 *     //...
 *  }
 * ```
 *
 */
export const useWalletContext = () => {
    return useContext(WaasContext);
};
/**
 * A convenience function to grab the first EVM address (i.e bip32 0/0 soft-derived path).
 * @param wallet The EVM wallet, or undefined -- i.e as returned from `const {wallet} = useWalletContext()`
 * @returns An EVM-ready address, when available.
 *
 * @example
 *
 *  const {wallet} = useWalletContext();
 *  const address = useEVMAddress(wallet);
 */
export const useEVMAddress = (wallet) => {
    return useFirstAddress(wallet, ProtocolFamily.EVM);
};
/**
 * Provides the first address on the given protocol family for this wallet.
 *
 * @param wallet The wallet, as returned from {@link useWalletContext}
 * @param protocolFamily The protocol family the address should be usable on. See {@link ProtocolFamily}
 * @returns Returns an {@link Address} when it is ready (undefined while deriving...)
 * @example
 *
 *    const {wallet} = useWalletContext();
 *    const address = useFirstAddress(wallet, ProtocolFamily.EVM);
 *
 */
export const useFirstAddress = (wallet, protocolFamily) => {
    const [address, setAddress] = useState();
    useEffect(() => {
        if (address != undefined && wallet == undefined) {
            setAddress(undefined);
        }
        else if (wallet != undefined) {
            wallet?.addresses.for(protocolFamily).then(setAddress);
        }
    }, [wallet]);
    return address;
};
