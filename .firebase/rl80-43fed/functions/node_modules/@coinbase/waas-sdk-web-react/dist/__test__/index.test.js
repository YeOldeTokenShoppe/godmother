import { jsx as _jsx } from "react/jsx-runtime";
/* eslint-disable require-await */
import { act, render, renderHook } from "@testing-library/react";
vi.mock("@coinbase/waas-sdk-web");
import { ProtocolFamily } from "@coinbase/waas-sdk-web";
import { afterEach, beforeEach, afterAll, beforeAll, describe, expect, expectTypeOf, it, vi, } from "vitest";
import { WalletProvider, useWalletContext, useFirstAddress, useEVMAddress, } from "../index.js";
import { MockWaas, MockAuth, MockWallet, MockUser, MockAddress } from "./mocks.js";
let web;
const mockWaasInitalization = () => {
    afterEach(() => {
        vi.resetAllMocks();
    });
    beforeEach(async () => {
        web = await import("@coinbase/waas-sdk-web");
        web.InitializeWaas = vi.fn().mockImplementation(async () => {
            return MockWaas;
        });
    });
};
describe("useWalletContext", () => {
    let result;
    let rerender;
    let wrapper;
    describe("when waas initialization succeeds", () => {
        mockWaasInitalization();
        it("component that doesnt use waas can render", async () => {
            const walletProviderProps = {
                collectAndReportMetrics: false,
            };
            await act(async () => {
                render(_jsx(WalletProvider, { ...walletProviderProps, children: _jsx("div", { children: "Child Component" }) }));
            });
            // TODO: assert on the state of the DOM using these docs
            // (https://testing-library.com/docs/react-testing-library/intro/)
        });
        describe("when a user session exists", () => {
            let wallet;
            beforeAll(() => {
                wallet = MockWallet;
            });
            beforeEach(async () => {
                MockAuth.user = MockUser;
                MockWaas.wallets.wallet = wallet;
                ({ result, rerender, wrapper } = await setupWalletContext({
                    collectAndReportMetrics: false,
                }));
            });
            afterEach(() => {
                MockAuth.user = undefined;
                MockWaas.wallets.wallet = MockWallet;
            });
            it("logs in the user", async () => {
                expect(result.current.user).toBeDefined();
            });
            describe("when a wallet is present", () => {
                it("sets the user's wallet", () => {
                    expect(result.current.wallet).toBe(MockWallet);
                });
            });
            describe("when a wallet is not present", () => {
                beforeAll(() => {
                    wallet = undefined;
                });
                afterAll(() => {
                    wallet = MockWallet;
                });
                it("does not set the user's wallet", () => {
                    expect(result.current.wallet).toBeUndefined();
                });
                it("allows the user to create the wallet", async () => {
                    // Without defining this function, typescript will complain about it not being defined.
                    let resolveCreate = (wallet) => {
                        return wallet;
                    };
                    const promise = new Promise(resolve => {
                        resolveCreate = resolve;
                    });
                    MockWaas.wallets.create = vi.fn().mockReturnValue(promise);
                    // Call the create function.
                    const createPromise = result.current.user.create("test-passcode");
                    // It sets the isCreatingWallet until the create function resolves.
                    rerender();
                    expect(result.current.isCreatingWallet).toBeTruthy();
                    resolveCreate(MockWallet);
                    await createPromise;
                    rerender();
                    // It sets the wallet in the context.
                    expect(result.current.wallet).toBe(MockWallet);
                    expect(result.current.isCreatingWallet).toBeFalsy();
                    expect(result.current.error).toBeUndefined();
                });
            });
        });
        describe("when a user session does not exist", () => {
            beforeEach(async () => {
                MockAuth.user = undefined;
                ({ result, rerender, wrapper } = await setupWalletContext({
                    collectAndReportMetrics: false,
                }));
            });
            it("does not log in the user", async () => {
                expect(result.current.user).toBeUndefined();
            });
            it("does not set the user's wallet", () => {
                expect(result.current.wallet).toBeUndefined();
            });
        });
        describe("when the user has an existing wallet", () => {
            beforeEach(async () => {
                ({ result, rerender, wrapper } = await setupWalletContext({
                    collectAndReportMetrics: false,
                }));
                MockWaas.wallets.wallet = vi.fn().mockReturnValue(MockWallet);
                await loginUser(result, rerender);
            });
            it("sets the wallet on the context", async () => {
                expect(result.current.wallet).toBe(MockWallet);
                expect(result.current.error).toBeUndefined();
            });
            describe("useEVMAddress", () => {
                it("returns the first address", async () => {
                    MockWallet.addresses.for = vi
                        .fn()
                        .mockReturnValue(Promise.resolve(MockAddress));
                    const { result: addressResult, rerender: addressRerender } = renderHook(() => {
                        return useEVMAddress(result.current.wallet);
                    }, { wrapper });
                    expect(MockWallet.addresses.for).toHaveBeenCalledWith(ProtocolFamily.EVM);
                    await MockWallet.addresses.for(ProtocolFamily.EVM);
                    addressRerender();
                    expect(result.current.wallet).toBe(MockWallet);
                    expect(addressResult.current).toBe(MockAddress);
                    expect(result.current.error).toBeUndefined();
                });
            });
            describe("useFirstAddress", () => {
                it("returns the first address", async () => {
                    MockWallet.addresses.for = vi
                        .fn()
                        .mockReturnValue(Promise.resolve(MockAddress));
                    const { result: addressResult, rerender: addressRerender } = renderHook(() => {
                        return useFirstAddress(result.current.wallet, ProtocolFamily.EVM);
                    }, { wrapper });
                    expect(MockWallet.addresses.for).toHaveBeenCalledWith(ProtocolFamily.EVM);
                    await MockWallet.addresses.for(ProtocolFamily.EVM);
                    addressRerender();
                    expect(result.current.wallet).toBe(MockWallet);
                    expect(addressResult.current).toBe(MockAddress);
                    expect(result.current.error).toBeUndefined();
                });
                describe("when the wallet becomes undefined", () => {
                    it("sets the address to undefined", async () => {
                        MockWallet.addresses.for = vi
                            .fn()
                            .mockReturnValue(Promise.resolve(MockAddress));
                        const { result: addressResult, rerender: addressRerender } = renderHook(() => {
                            return useFirstAddress(result.current.wallet, ProtocolFamily.EVM);
                        }, { wrapper });
                        await MockWallet.addresses.for(ProtocolFamily.EVM);
                        addressRerender();
                        expect(addressResult.current).toBe(MockAddress);
                        // Logout the user to set the wallet to undefined.
                        web.Logout = vi.fn().mockImplementation(() => Promise.resolve());
                        await result.current.waas?.logout();
                        rerender();
                        addressRerender();
                        expect(addressResult.current).toBeUndefined();
                    });
                });
            });
        });
        describe("when the user does not have an existing wallet", () => {
            beforeEach(async () => {
                ({ result, rerender } = await setupWalletContext({
                    collectAndReportMetrics: false,
                    enableHostedBackups: true,
                }));
                // The wallet does not exist on the `wallets` object.
                MockWaas.wallets.wallet = vi.fn().mockReturnValue(undefined);
                await loginUser(result, rerender);
                // It does not set a wallet if one does not already exist.
                rerender();
                expect(result.current.wallet).toBeUndefined();
                expect(result.current.error).toBeUndefined();
                expect(result.current.isCreatingWallet).toBeFalsy();
            });
            describe("when a user is logged out", () => {
                beforeEach(async () => {
                    // Without defining this function, typescript will complain about it not being defined.
                    let resolveLogout = (_param) => {
                        return;
                    };
                    web.Logout = vi.fn().mockImplementation(() => new Promise(resolve => {
                        resolveLogout = resolve;
                    }));
                    // Call the logout function.
                    const logoutPromise = result.current.waas?.logout();
                    // It sets isLoggingIn until the logout function resolves.
                    rerender();
                    expect(result.current.isLoggingIn).toBeTruthy();
                    resolveLogout(undefined);
                    await logoutPromise;
                    rerender();
                });
                it("does not reset the WaaS object", async () => {
                    expect(result.current.waas).toBeDefined();
                });
                it("resets the user and user-scoped properties", async () => {
                    expect(result.current.user).toBeUndefined();
                    expect(result.current.wallet).toBeUndefined();
                    expect(result.current.isLoggingIn).toBeFalsy();
                    expect(result.current.error).toBeUndefined();
                });
                it("allows the user to be logged in again", async () => {
                    // It does not reset the WaaS object.
                    expect(result.current.waas).toBeDefined();
                    await loginUser(result, rerender);
                    expect(result.current.waas).toBeDefined();
                    expect(result.current.user).toBeDefined();
                    expect(result.current.error).toBeUndefined();
                });
            });
            it("allows the user to create the wallet", async () => {
                // Without defining this function, typescript will complain about it not being defined.
                let resolveCreate = (wallet) => {
                    return wallet;
                };
                const promise = new Promise(resolve => {
                    resolveCreate = resolve;
                });
                MockWaas.wallets.create = vi.fn().mockReturnValue(promise);
                // Call the create function.
                const createPromise = result.current.user.create("test-passcode");
                // It sets the isCreatingWallet until the create function resolves.
                rerender();
                expect(result.current.isCreatingWallet).toBeTruthy();
                resolveCreate(MockWallet);
                await createPromise;
                rerender();
                // It sets the wallet in the context.
                expect(result.current.wallet).toBe(MockWallet);
                expect(result.current.isCreatingWallet).toBeFalsy();
                expect(result.current.error).toBeUndefined();
            });
            it("throws an error when creating a wallet fails", async () => {
                // Without defining this function, typescript will complain about it not being defined.
                let rejectCreate = (wallet) => {
                    return wallet;
                };
                const promise = new Promise((resolve, reject) => {
                    rejectCreate = reject;
                });
                MockWaas.wallets.create = vi.fn().mockReturnValue(promise);
                // Call the create function.
                const createPromise = result.current.user?.create("test-passcode");
                // It sets the isCreatingWallet until the create function resolves.
                rerender();
                expect(result.current.isCreatingWallet).toBeTruthy();
                rejectCreate("failed to create wallet");
                try {
                    await createPromise;
                }
                catch (error) {
                    expect(error).toBe("failed to create wallet");
                }
                rerender();
                // The wallet is not set.
                expect(result.current.wallet).toBeUndefined;
                expect(result.current.isCreatingWallet).toBeFalsy();
                expect(result.current.error).toBeUndefined();
            });
            it("allows the user to restore from hosted backup", async () => {
                expect(result.current.isCreatingWallet).toBeFalsy();
                // Without defining this function, typescript will complain about it not being defined.
                let resolveRestore = (wallet) => {
                    return wallet;
                };
                const promise = new Promise(resolve => {
                    resolveRestore = resolve;
                });
                MockWaas.wallets.restoreFromHostedBackup = vi
                    .fn()
                    .mockReturnValue(promise);
                const restoreFromHostedBackup = result.current.user?.restoreFromHostedBackup;
                if (!restoreFromHostedBackup) {
                    throw new Error("restoreFromHostedBackup is undefined");
                }
                // Restore the wallet from hosted backup.
                const restorePromise = restoreFromHostedBackup("test-passcode");
                // It sets the isCreatingWallet until the restoreFromHostedBackup function resolves.
                rerender();
                expect(result.current.isCreatingWallet).toBeTruthy();
                expect(result.current.wallet).toBeUndefined();
                expect(MockWaas.wallets.restoreFromHostedBackup).toHaveBeenCalledWith("test-passcode");
                resolveRestore(MockWallet);
                await restorePromise;
                rerender();
                // It sets the wallet in the context.
                expect(result.current.wallet).toEqual(MockWallet);
                expect(result.current.isCreatingWallet).toBeFalsy();
                expect(result.current.error).toBeUndefined();
            });
            it("throws an error when restoring from hosted backup errors", async () => {
                expect(result.current.isCreatingWallet).toBeFalsy();
                // Without defining this function, typescript will complain about it not being defined.
                let rejectRestore = (wallet) => {
                    return wallet;
                };
                const promise = new Promise((resolve, reject) => {
                    rejectRestore = reject;
                });
                MockWaas.wallets.restoreFromHostedBackup = vi
                    .fn()
                    .mockReturnValue(promise);
                const restoreFromHostedBackup = result.current.user?.restoreFromHostedBackup;
                if (!restoreFromHostedBackup) {
                    throw new Error("restoreFromHostedBackup is undefined");
                }
                // Restore the wallet from hosted backup.
                const restorePromise = restoreFromHostedBackup("test-passcode");
                // It sets the isCreatingWallet until the restoreFromHostedBackup function resolves.
                rerender();
                expect(result.current.isCreatingWallet).toBeTruthy();
                expect(result.current.wallet).toBeUndefined();
                expect(MockWaas.wallets.restoreFromHostedBackup).toHaveBeenCalledWith("test-passcode");
                rejectRestore("failed to restore from hosted backup");
                try {
                    await restorePromise;
                }
                catch (error) {
                    expect(error).toBe("failed to restore from hosted backup");
                }
                rerender();
                // The wallet is not set.
                expect(result.current.wallet).toBeUndefined;
                expect(result.current.isCreatingWallet).toBeFalsy();
                expect(result.current.error).toBeUndefined();
            });
            it("allows the user to restore from backup", async () => {
                expect(result.current.isCreatingWallet).toBeFalsy();
                // Without defining this function, typescript will complain about it not being defined.
                let resolveRestore = (wallet) => {
                    return wallet;
                };
                MockWaas.wallets.restoreFromBackup = vi.fn().mockImplementationOnce(() => new Promise(resolve => {
                    resolveRestore = resolve;
                }));
                const restoreFromBackup = result.current.user?.restoreFromBackup;
                if (!restoreFromBackup) {
                    throw new Error("restoreFromBackup is undefined");
                }
                // Restore the wallet from hosted backup.
                const restorePromise = restoreFromBackup(MockWallet.backup, "test-passcode");
                // It sets the isCreatingWallet until the restoreFromHostedBackup function resolves.
                rerender();
                expect(result.current.isCreatingWallet).toBeTruthy();
                expect(result.current.wallet).toBeUndefined();
                expect(MockWaas.wallets.restoreFromBackup).toHaveBeenCalledWith(MockWallet.backup, "test-passcode");
                resolveRestore(MockWallet);
                await restorePromise;
                rerender();
                // It sets the wallet in the context.
                expect(result.current.wallet).toEqual(MockWallet);
                expect(result.current.isCreatingWallet).toBeFalsy();
                expect(result.current.error).toBeUndefined();
            });
            it("throws an error when restoring from backup errors", async () => {
                expect(result.current.isCreatingWallet).toBeFalsy();
                // Without defining this function, typescript will complain about it not being defined.
                let rejectRestore = (wallet) => {
                    return wallet;
                };
                const promise = new Promise((resolve, reject) => {
                    rejectRestore = reject;
                });
                MockWaas.wallets.restoreFromBackup = vi.fn().mockReturnValue(promise);
                const restoreFromBackup = result.current.user?.restoreFromBackup;
                if (!restoreFromBackup) {
                    throw new Error("restoreFromBackup is undefined");
                }
                // Restore the wallet from hosted backup.
                const restorePromise = restoreFromBackup(MockWallet.backup, "test-passcode");
                // It sets the isCreatingWallet until the restoreFromHostedBackup function resolves.
                rerender();
                expect(result.current.isCreatingWallet).toBeTruthy();
                expect(result.current.wallet).toBeUndefined();
                expect(MockWaas.wallets.restoreFromBackup).toHaveBeenCalledWith(MockWallet.backup, "test-passcode");
                rejectRestore("failed to restore from backup");
                try {
                    await restorePromise;
                }
                catch (error) {
                    expect(error).toBe("failed to restore from backup");
                }
                rerender();
                // The wallet is not set.
                expect(result.current.wallet).toBeUndefined;
                expect(result.current.isCreatingWallet).toBeFalsy();
                expect(result.current.error).toBeUndefined();
            });
        });
        describe("when hosted backups is disabled", () => {
            it("does not expose the restoreFromHostedBackup function", async () => {
                const { result, rerender } = await setupWalletContext({ collectAndReportMetrics: false });
                await loginUser(result, rerender);
                rerender();
                expect(result.current.waas).toBeDefined();
                expect(result.current.user?.restoreFromHostedBackup).toBeUndefined();
            });
        });
        describe("when login is called multiple times", () => {
            const loginOptions = { provideAuthToken: () => Promise.resolve("test-token") };
            let loginPromise;
            beforeEach(async () => {
                ({ result, rerender, wrapper } = await setupWalletContext({
                    collectAndReportMetrics: false,
                }));
            });
            describe("when the user is already logged in", () => {
                let resolveLogin = (wallet) => { };
                let user;
                beforeEach(async () => {
                    MockAuth.login = vi.fn().mockReturnValue(new Promise(resolve => {
                        resolveLogin = resolve;
                    }));
                    // Initiate the first login.
                    const loginPromise = result.current.waas.login(loginOptions);
                    rerender();
                    expect(result.current.isLoggingIn).toBeTruthy();
                    expect(result.current.waas).toBeDefined();
                    resolveLogin(MockWaas);
                    // Complete the first login.
                    user = await loginPromise;
                    rerender();
                });
                it("logs in the user", async () => {
                    expect(result.current.user).toBeDefined();
                    expect(user).toBeDefined();
                    expect(result.current.user).toBe(user);
                });
                it("throws an error on subsequent logins", async () => {
                    // The subsequent login call throws an error.
                    await expect(result.current.waas.login(loginOptions)).rejects.toThrowError("User is already logged in.");
                    expect(MockAuth.login).toHaveBeenCalledOnce();
                });
            });
            describe("when the user is currently logging in", () => {
                let resolveLogin = (wallet) => { };
                let loginPromise;
                beforeEach(async () => {
                    MockAuth.login = vi.fn().mockReturnValue(new Promise(resolve => {
                        resolveLogin = resolve;
                    }));
                    loginPromise = result.current.waas.login(loginOptions);
                    rerender();
                });
                it("throws an error and does not attempt to login again", async () => {
                    expect(result.current.isLoggingIn).toBeTruthy();
                    // The subsequent login call throws an error.
                    await expect(result.current.waas.login(loginOptions)).rejects.toThrowError("Cannot login while already logging in");
                    // Complete the first login.
                    resolveLogin(MockWaas);
                    const user = await loginPromise;
                    rerender();
                    // The user is only logged in once, even with multiple login calls.
                    expect(MockAuth.login).toHaveBeenCalledOnce();
                    // Logs in the user.
                    expect(result.current.user).toBeDefined();
                    expect(user).toBeDefined();
                    expect(result.current.user).toBe(user);
                });
            });
        });
        it("returns an error when login fails", async () => {
            const { result, rerender } = await setupWalletContext({ collectAndReportMetrics: false });
            // Mock the auth login function to error.
            MockAuth.login = vi.fn().mockReturnValue(Promise.reject("login failed"));
            const loginOptions = { provideAuthToken: () => Promise.resolve("test-token") };
            await expect(result.current.waas.login(loginOptions)).rejects.toThrowError("login failed");
            rerender();
            expect(MockAuth.login).toHaveBeenCalledWith(loginOptions);
            expect(result.current.waas).toBeDefined();
            expect(result.current.user).toBeUndefined();
            expect(result.current.isLoggingIn).toBeFalsy();
        });
    });
});
const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
// loginUser logs in the user and asserts on the initial, intermediate, and final states.
const loginUser = async (result, rerender) => {
    expect(result.current.isLoggingIn).toBeFalsy();
    expect(result.current.waas).toBeDefined();
    // Without defining this function, typescript will complain about it not being defined.
    let resolveLogin = (wallet) => { };
    MockAuth.login = vi.fn().mockReturnValue(new Promise(resolve => {
        resolveLogin = resolve;
    }));
    const loginOptions = { provideAuthToken: () => Promise.resolve("test-token") };
    const loginPromise = result.current.waas.login(loginOptions);
    rerender();
    expect(result.current.isLoggingIn).toBeTruthy();
    resolveLogin(MockWaas);
    const user = await loginPromise;
    rerender();
    // It logs in the user.
    expect(MockAuth.login).toHaveBeenCalledWith(loginOptions);
    expect(user).toBeDefined();
    expectTypeOf(user).toEqualTypeOf();
    expect(result.current.user).toBeDefined();
    expect(result.current.user).toBe(user);
    // It does not set an error.
    expect(result.current.error).toBeUndefined();
};
const setupWalletContext = async (walletProviderProps) => {
    const wrapper = ({ children }) => {
        return _jsx(WalletProvider, { ...walletProviderProps, children: children });
    };
    const { result, rerender } = renderHook(() => useWalletContext(), { wrapper });
    expect(result.current.waas).toBeUndefined();
    expect(result.current.isCreatingWallet).toBeFalsy();
    expect(result.current.error).toBeUndefined();
    expect(result.current.wallet).toBeUndefined();
    await wait(100);
    rerender();
    return { result, rerender, wrapper };
};
